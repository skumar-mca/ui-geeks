"use strict";(self.webpackChunkui_geeks_in=self.webpackChunkui_geeks_in||[]).push([[5262],{15262:(e,t,l)=>{l.r(t),l.d(t,{default:()=>m});var n=l(67294),o=l(81391),c=l(87398),a=l(68947),r=l(12050),s=l(9167),u=[{label:n.createElement(n.Fragment,null,n.createElement(s.B,null,"Local Scope")," (Own scope)")},{label:n.createElement(n.Fragment,null,n.createElement(s.B,null,"Enclosing Scope")," (Can be block, function or module scope)")},{label:n.createElement(s.B,null,"Global Scope")}];const m=function(){return n.createElement(n.Fragment,null,n.createElement(c.Z,{as:"h3"},"Closure Scope Chain"),n.createElement(a.Z,null,"Every closure has three scopes:",n.createElement(s.GS,{items:u})),n.createElement(a.Z,null,"When nested functions themselves contain nested functions, this effectively creates a chain of function scopes."),n.createElement(o.Z,null,"const globalVal = 10; // Global Scope\nfunction sum(a) {\n  // outer scope\n  return function(b) {\n    // outer scope\n    return function(c){\n      // local scope\n      return a + b + c + globalVal;\n    }\n  }\n}\n\nconst result = sum(1)(2)(3);\nconsole.log(result)\t// 16"),n.createElement(a.Z,null,"There's a series of nested functions, all of which have access to the outer scope. In this context, it can be said that closures have access to all outer function scopes."),n.createElement(a.Z,null,"Closures can access members in ",n.createElement(s.BI,null,"module scope")," too. We'll learn about ",n.createElement(s.B,null,"modules")," in later sections, but for now, let's just try to understand module scope with closures."),n.createElement(o.Z,null,"// my-module.js\nlet x = 5;\nexport const getX = () => x;\nexport const setX = (val) => { x = val; };\n"),n.createElement(a.Z,null,"Here, the module ",n.createElement(s.I,null,"exports")," a pair of ",n.createElement(s.I,null,"getter-setter"),n.createElement(r.Z,null),"functions, which close over the module-scoped variable ",n.createElement(s.B,null,'"x"'),". Even when ",n.createElement(s.B,null,'"x"')," is not directly accessible from other modules, it can be read/written with the help of exported functions."),n.createElement(o.Z,null,'import { getX, setX } from "./my-module.js";\nconsole.log(getX()) // 5\nsetX(6);\nconsole.log(getX()) // 6'),n.createElement(a.Z,null,"Closures can close over imported values as well, which are regarded as",n.createElement(s.B,null,'"live bindings"'),", because when the original value changes, the imported members changes automatically."),n.createElement(o.Z,null,"// my-module.js\nexport let x =1;\nYesexport const setX = (val) => { x = val; };\n"),n.createElement(o.Z,null,'// closure-creator.js\nimport { x } from "./my-module.js";\nexport const getX = () => x;\n// Live binding is created for variable "x"'),n.createElement(o.Z,null,'// main-program.js\nimport { getX } from "./closure-creator.js";\nimport { setX } from "./my-module.js";\nconsole.log(getX())\t// 1\nsetX(2);\nconsole.log(getX())\t// 2\n'),n.createElement(a.Z,null,n.createElement(s.BI,null,"setX(2);"),n.createElement(s.cJ,null),"Above statement updated the value of ",n.createElement(s.B,null,'"x"'),", placed in",n.createElement(r.Z,null),n.createElement(s.IU,null,"my-module.js"),", and at the same time updated the value of",n.createElement(s.B,null,'"x"')," in ",n.createElement(s.IU,null,"closure-creator.js")," with the help of",n.createElement(s.B,null,"live binding"),"."))}}}]);