"use strict";(self.webpackChunkui_geeks_in=self.webpackChunkui_geeks_in||[]).push([[5201],{45201:(e,n,t)=>{t.r(n),t.d(n,{default:()=>m});var r=t(67294),l=t(81391),a=t(91573),o=t(87398),c=t(68947),i=t(12050),u=t(9167);const m=function(){return r.createElement(r.Fragment,null,r.createElement(o.Z,{as:"h4"},"componentDidCatch()"),r.createElement(c.Z,null,"It is invoked after an error has been thrown by a descendant component."),r.createElement(l.Z,null,"componentDidCatch(error, info)"),r.createElement(c.Z,null,r.createElement(u.B,null,"error"),": Error thrown from the component."),r.createElement(c.Z,null,r.createElement(u.B,null,"info"),": An object with a ",r.createElement(u.BI,null,"componentStack")," key containing information about which component threw the error."),r.createElement(c.Z,null,"It is called during the ",r.createElement(u.B,null,'"commit"')," phase, so ",r.createElement(u.I,null,"side-effects"),r.createElement(i.Z,null)," are permitted. It should be used for things like logging the errors."),r.createElement(c.Z,null,r.createElement(u.IU,null,"Example:"),r.createElement(l.Z,{language:a.r.JSX},'class ErrorBoundary extends React.Component {\n  constructor(props) { \n    super(props);\n    this.state = { hasError : false };\n  }\n\n  static getDerivedStateFromError(error) {\n    // Update state so the next render will show the fallback UI\n    return { hasError : true };\n  }\n\n  componentDidCatch(error, info) {\n    // Example "componentStack"\n    // in ComponentThatThrows (created by App)\n    // in ErrorBoundary (created by App)\n    // in div (created by App)\n    // in App\n    logError(info.componentStack);\n  }\n\n  render() {\n    if(this.state.hasError) {\n      // Render any fallback UI for error handling\n      return <h1>Something went wrong.</h1>\n    }\n\n    return this.props.children;\n  }\n}')),r.createElement(c.Z,null,r.createElement(u.B,null,"Production")," and ",r.createElement(u.B,null,"development")," builds of React slightly differ in the way ",r.createElement(u.I,null,"componentDidCatch()")," handles errors."),r.createElement(c.Z,null,"On ",r.createElement(u.B,null,"development"),", the errors will ",r.createElement(u.BI,null,"bubble up")," to the",r.createElement(i.Z,null)," ",r.createElement(u.BI,null,"window"),", this means that any ",r.createElement(u.BI,null,"window.onerror"),r.createElement(i.Z,null)," or ",r.createElement(u.BI,null,'window.addEventListener("error", callback)')," will intercept the errors that have been caught by ",r.createElement(u.I,null,"componentDidCatch()"),"."),r.createElement(c.Z,null,"On ",r.createElement(u.B,null,"production"),", the errors will ",r.createElement(u.BI,null,"not bubble up"),", which means any ancestor error handler will only receive errors ",r.createElement(i.Z,null),r.createElement(u.BI,null,"not explicitly caught")," by componentDidCatch()."))}}}]);