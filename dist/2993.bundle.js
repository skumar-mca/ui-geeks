"use strict";(self.webpackChunkui_geeks_in=self.webpackChunkui_geeks_in||[]).push([[2993],{22993:(e,t,n)=>{n.r(t),n.d(t,{default:()=>o});var l=n(67294),a=n(81391),r=n(91573),c=n(87398),u=n(68947),i=n(12050),s=n(9167);const o=function(){return l.createElement(l.Fragment,null,l.createElement(c.Z,{as:"h3"},"useReducer()"),l.createElement(u.Z,null,"This Hooks is an alternative to ",l.createElement(s.I,null,"useState")," Hook. It is usually preferable over ",l.createElement(s.I,null,"useState")," when we have complex state logic that involves multiple sub-values or when the next state depends on the previous one. useReducer also optimizes the performance of the component."),l.createElement(u.Z,null,l.createElement(s.IU,null,"Syntax:"),l.createElement(a.Z,{language:r.r.JSX},"const [state, dispatch] = useReducer(reducer, intialArg, init);")),l.createElement(u.Z,null,l.createElement(s.B,null,"state"),": This variable holds the current value of the state."),l.createElement(u.Z,null,l.createElement(s.B,null,"dispatch"),": This method is used to trigger a change to the state value."),l.createElement(u.Z,null,l.createElement(s.B,null,"reducer"),": This is a method of type ",l.createElement(i.Z,null),l.createElement(s.BI,null,"(state, action) => newState"),". It accepts ",l.createElement(s.B,null,'"action"'),l.createElement(i.Z,null)," from ",l.createElement(s.B,null,"dispatch"),", uses the ",l.createElement(s.BI,null,"current state")," to compute ",l.createElement(s.BI,null,"newState")," and returns the newState."),l.createElement(u.Z,null,l.createElement(s.B,null,"intialArg"),": It is the initial value of the state."),l.createElement(u.Z,null,l.createElement(s.B,null,"init"),": This is an ",l.createElement(s.I,null,"optional function"),", used for ",l.createElement(i.Z,null),l.createElement(s.I,null,"lazy initialization")," of the ",l.createElement(s.I,null,"state"),". If provided, the initial state will be set to ",l.createElement(s.BI,null,"init(initialArg)"),". It lets us extract the logic for calculating the initial state outside the reducer."),l.createElement(u.Z,null,l.createElement(s.IU,null,"Example:"),l.createElement(a.Z,{language:r.r.JSX},"const init = (initialCount) => {\n  return { count: initialCount };\n}"),l.createElement(a.Z,{language:r.r.JSX},'const reducer(state, action) {\n  switch(action.type) {\n    case "increment": return { count : state.count + 1 };\n    case "decrement": return { count : state.count - 1 };\n    case "reset": return init(action.payload);\n    default: throw new Error();\n  }\n}')),l.createElement(a.Z,{language:r.r.JSX},'const Counter = (props) => {\n  const { initialCount } = props;\n  const [state, dispatch] = useReducer(reducer, initialCount, init);\n\n  const handleReset = () => {\n    dispatch({ type: "reset", payload: initialCount });\n  }\n  const handleIncrement = () => { dispatch({ type: "increment" }); \t}\n  const handleDecrement = () => { dispatch({ type: "decrement" }); }\n\n  return <>\n    Count: {state.count}\n    <button onClick={handleReset}>Reset</button>\n    <button onClick={handleIncrement}>Increment</button>\n    <button onClick={handleDecrement}>Decrement</button>\n  </>\n}'))}}}]);