"use strict";(self.webpackChunkui_geeks_in=self.webpackChunkui_geeks_in||[]).push([[9745,651,6636],{20651:(e,n,t)=>{t.r(n),t.d(n,{default:()=>m});var l=t(67294),a=t(81391),r=t(91573),c=t(87398),o=t(68947),u=t(12050),s=t(9167);const m=function(){return l.createElement(l.Fragment,null,l.createElement(c.Z,{as:"h2"},"Uncontrolled Components"),l.createElement(o.Z,null,"Components whose values are not controlled by React, instead are controlled by DOM itself are called ",l.createElement(s.B,null,'"uncontrolled components"'),". For example, an ",l.createElement(s.I,null,'<input type="file" />')," is always an uncontrolled component because its value can only be set by a user, and not programmatically."),l.createElement(o.Z,null,"To write an uncontrolled component, instead of writing an event handler for every state update, we can ",l.createElement(s.B,null,"use a ref")," to get form values from the DOM. ",l.createElement(s.BI,null,"Refs")," are used to access DOM nodes or React elements in uncontrolled components. React prefers to avoid using ",l.createElement(s.BI,null,"refs")," for anything that can be done declaratively."),l.createElement(o.Z,null,l.createElement(s.IU,null,"Example 1:"),l.createElement(u.Z,null)," Using ref in ",l.createElement(s.B,null,"class components.")),l.createElement(o.Z,null,"Below code focuses the ",l.createElement(s.I,null,"<input />")," element on mount."),l.createElement(o.Z,null,l.createElement(a.Z,{language:r.r.JSX},"class AutoFocusInput extends React.Component {\n  constructor(props) {\n    super(props);\n    this.textInput = React.createRef();\n  }\n\t\n  componentDidMount() {\n    this.textInput.current.focusTextInput();\n  }\n\n  render() {\n    return <input type=”text” ref={this.textInput} />\n  }\n}")),l.createElement(o.Z,null,l.createElement(s.IU,null,"Example 2:"),l.createElement(u.Z,null)," Using ref in ",l.createElement(s.B,null,"function components.")),l.createElement(o.Z,null,l.createElement(a.Z,{language:r.r.JSX},"const AutoFocusInput = () => {\n  const textInput = useRef();\n  useEffect(() =>  {\n    textInput.current.focusTextInput();\n  },[ ]);\n  return <input type=”text” ref={this.textInput} />\n}\n")),l.createElement(o.Z,null,"React will assign the ",l.createElement(s.BI,null,'"current"')," property with the DOM element when the component ",l.createElement(s.I,null,"mounts"),", and assign it back to ",l.createElement(s.BI,null,"null"),l.createElement(u.Z,null)," when it ",l.createElement(s.I,null,"unmounts"),". For ",l.createElement(s.I,null,"class components"),",",l.createElement(u.Z,null)," ",l.createElement(s.BI,null,"ref")," updates happen before ",l.createElement(u.Z,null),l.createElement(s.BI,null,"componentDidMount()")," or ",l.createElement(s.BI,null,"componentDidUpdate()")," lifecycle methods."))}},79745:(e,n,t)=>{t.r(n),t.d(n,{default:()=>c});var l=t(67294),a=t(20651),r=t(56636);const c=function(){return l.createElement(l.Fragment,null,l.createElement(a.default,null),l.createElement(r.default,null))}},56636:(e,n,t)=>{t.r(n),t.d(n,{default:()=>u});var l=t(67294),a=t(87398),r=t(68947),c=t(9167),o=[{label:"Managing focus, text selection, or media playback."},{label:"Integrating with third-party DOM libraries."}];const u=function(){return l.createElement(l.Fragment,null,l.createElement(a.Z,{as:"h3"},"When to use Uncontrolled Components"),l.createElement(r.Z,null,"Since an uncontrolled component keeps the source of truth in the DOM, it is sometimes easier to integrate React and non-React code when using uncontrolled components. It can be slightly less code if we want to be quick and dirty. Otherwise, we should use controlled components."),l.createElement(c.GS,{unOrdered:!0,items:o}))}}}]);