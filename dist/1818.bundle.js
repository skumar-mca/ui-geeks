"use strict";(self.webpackChunkui_geeks_in=self.webpackChunkui_geeks_in||[]).push([[1818],{31818:(e,n,t)=>{t.r(n),t.d(n,{default:()=>c});var l=t(67294),a=t(81391),r=t(87398),i=t(68947),o=t(9167);const c=function(){return l.createElement(l.Fragment,null,l.createElement(r.Z,{as:"h2"},"Variable Hoisting"),l.createElement(i.Z,null,"In JavaScript, we can refer to a variable which is declared later, without getting an exception/error. This concept is known as",l.createElement(o.B,null,"hoisting"),". Variables in JavaScript are ",l.createElement(o.B,null,'"hoisted"')," (or",l.createElement(o.B,null,'"lifted"'),") to the top of the function or statement. However, variables that are hoisted return a value of ",l.createElement(o.BI,null,"undefined"),"."),l.createElement(a.Z,null,"// Example 1:\nconsole.log(x === undefined);\t// true\nvar x=10;\n\n// Example 2:\nvar a = 100;\n(function() {\n  console.log(a);   // undefined\n  var a = 50;\n})();\n"),l.createElement(o.cJ,null),l.createElement(i.Z,null,l.createElement(o.BI,null,"let")," and ",l.createElement(o.BI,null,"const")," are hoisted but not initialized. Referencing the variable in the block before the declaration results in",l.createElement(o.B,null,"ReferenceError"),", because the variable is in a",l.createElement(o.B,null,'"temporal dead zone"')," from the start of the block until the declaration is processed."),l.createElement(a.Z,null,"console.log(x); // ReferenceError\nlet x = 10;\n"))}}}]);