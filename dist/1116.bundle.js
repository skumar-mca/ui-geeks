"use strict";(self.webpackChunkui_geeks_in=self.webpackChunkui_geeks_in||[]).push([[1116,8259,9685,8482,4691,4441,8744,6984,2233],{55449:(e,t,l)=>{l.r(t),l.d(t,{default:()=>c});var n=l(67294),r=l(81391),a=l(87398),o=l(26006),m=l(68947),u=l(9167);const c=function(){return n.createElement(n.Fragment,null,n.createElement(a.Z,{as:"h3"},"Default Export"),n.createElement(m.Z,null,"There can be only one ",n.createElement(u.BI,null,"default export")," per module. They can be imported with any name. Default members are imported without curly brackets ","{ }","."),n.createElement(r.Z,null,'// "./exported-module.js"\nexport default let x = 10;\nexport default function greet() { console.log("Hello!"); };'),n.createElement(o.Z,null,"If multiple default exports are written in a module, each default export will ",n.createElement(u.B,null,"overwrite")," the previous one. In the above example,",n.createElement(u.B,null,'"greet()"')," will be the default exported member."),n.createElement(r.Z,null,'// "./main-program.js"\nimport greet from "./exported-module.js";\ngreet();  // "Hello!"'),n.createElement(o.Z,null,"The export default syntax allows any expression. For example:"," ",n.createElement(u.B,null,"export default 10 + 20"),";"))}},8259:(e,t,l)=>{l.r(t),l.d(t,{default:()=>u});var n=l(67294),r=l(68947),a=l(12050),o=l(9167),m=[{label:"Named export"},{label:"Default export"}];const u=function(){return n.createElement(n.Fragment,null,n.createElement(r.Z,null,"The ",n.createElement(o.B,null,"export")," declaration is used to ",n.createElement(o.I,null,"export")," values from a JavaScript module. Exported modules can then be imported into other programs with the ",n.createElement(o.I,null,"import declaration")," or ",n.createElement(o.I,null,"dynamic import"),". When a module updates the value of a binding that is exported, the update will be visible in its imported value. This update mechanism is called ",n.createElement(o.B,null,"live binding"),"."),n.createElement(r.Z,null,"In order to use the ",n.createElement(o.I,null,"export")," declaration, the file must be interpreted by the runtime as a ",n.createElement(o.I,null,"module"),". In HTML, this is done by adding the ",n.createElement(o.BI,null,'type="module"')," attribute to the ",n.createElement(o.BI,null,"<script>"),n.createElement(a.Z,null),"tag. Modules are automatically interpreted in ",n.createElement(o.B,null,"strict mode"),"."),n.createElement(r.Z,null,"Every module can have two types of export:",n.createElement(o.GS,{unOrdered:!0,items:m})))}},68522:(e,t,l)=>{l.r(t),l.d(t,{default:()=>s});var n=l(67294),r=l(87398),a=l(68947),o=l(55449),m=l(8259),u=l(85786),c=l(99685),i=l(18482);const s=function(){return n.createElement(n.Fragment,null,n.createElement(r.Z,{as:"h2"},"export statement"),n.createElement(a.Z,null,n.createElement(m.default,null),n.createElement(u.default,null),n.createElement(o.default,null),n.createElement(c.default,null),n.createElement(i.default,null)))}},85786:(e,t,l)=>{l.r(t),l.d(t,{default:()=>c});var n=l(67294),r=l(81391),a=l(87398),o=l(26006),m=l(68947),u=l(9167);const c=function(){return n.createElement(n.Fragment,null,n.createElement(a.Z,{as:"h3"},"Named Export"),n.createElement(m.Z,null,"As the name suggests, ",n.createElement(u.BI,null,"named exports")," are one which have a"," ",n.createElement(u.B,null,"unique name"),". A module can have multiple named exports. While importing, named exports must be referred to by the exact same name (optionally renaming it with ",n.createElement(u.B,null,"as"),"). Named exports should always be enclosed within ","{ }"," brackets."),n.createElement(r.Z,null,'export let myExportedVal = 10;\nexport function myFunc() { console.log("hello");\n'),n.createElement(o.Z,null,n.createElement(u.B,null,"export ","{}")," does not export an empty object. It is a no-op declaration that exports nothing."),n.createElement(a.Z,{as:"h4"},"Named export can be renamed while exporting from the module"),n.createElement(m.Z,null,"The ",n.createElement(u.B,null,"as")," operator can be used to rename the export declaration."),n.createElement(r.Z,null,'const func( ) { console.log("hello");\nexport { func as myFunction };\n'),n.createElement(m.Z,null,"The ",n.createElement(u.I,null,"import")," declaration will have to use ",n.createElement(u.BI,null,"myFunction")," in order to access it."),n.createElement(m.Z,null,"Exported members can also be renamed to something that's not a valid identifier."),n.createElement(r.Z,null,'const func( ) { console.log("hello");\nexport { func as "my-func" };'),n.createElement(m.Z,null,"The ",n.createElement(u.I,null,"import")," declaration will have to use ",n.createElement(u.BI,null,'"my-func"')," in order to access it."),n.createElement(m.Z,null,"The ",n.createElement(u.I,null,"export")," declarations are not subject to",n.createElement(u.B,null,"temporal dead zone")," rules. The ",n.createElement(u.I,null,"export")," declaration can be written, even before declaring the exported members. This would work because the ",n.createElement(u.I,null,"export")," statement is only a declaration, it does not utilize/evaluate the exported member."),n.createElement(r.Z,null,"export { x };\nlet x = 10;\n"),n.createElement(m.Z,null,"The ",n.createElement(u.I,null,"export")," declaration of ",n.createElement(u.B,null,'"x"')," is written even before declaring ",n.createElement(u.B,null,'"x"'),"."))}},99685:(e,t,l)=>{l.r(t),l.d(t,{default:()=>u});var n=l(67294),r=l(81391),a=l(87398),o=l(68947),m=l(9167);const u=function(){return n.createElement(n.Fragment,null,n.createElement(a.Z,{as:"h3"},"Re-exporting/Aggregation"),n.createElement(o.Z,null,"A module can also export the members which are exported from other modules without writing two separate import/export statements. This concept is called ",n.createElement(m.I,null,"Re-exporting")," or ",n.createElement(m.I,null,"Aggregation"),". The",n.createElement(m.B,null,"from")," keyword is used with export declaration."),n.createElement(r.Z,null,'export { sayHi, sayBye } from "./exportedModule.js";'),n.createElement(o.Z,null,"We'll have to write two different ",n.createElement(m.I,null,"import/export")," statements for the same purpose, without ",n.createElement(m.I,null,"aggregation"),"."),n.createElement(r.Z,null,'import { sayHi, sayBye } from "./exportedModule.js";\nexport { sayHi, sayBye };\n'))}},18482:(e,t,l)=>{l.r(t),l.d(t,{default:()=>c});var n=l(67294),r=l(81391),a=l(87398),o=l(68947),m=l(12050),u=l(9167);const c=function(){return n.createElement(n.Fragment,null,n.createElement(a.Z,{as:"h3"},"Wild-card (*) export statement"),n.createElement(o.Z,null,"Wild card ",n.createElement(u.I,null,"export")," statement re-exports all the",n.createElement(m.Z,null),n.createElement(u.I,null,"named exports")," of a given",n.createElement(m.Z,null),n.createElement(u.I,null,"module"),", as the ",n.createElement(u.I,null,"named exports")," of the current ",n.createElement(u.I,null,"module"),". But the ",n.createElement(u.I,null,"default export")," of the given module is not re-exported."),n.createElement(o.Z,null,n.createElement(u.IU,null,"Syntax:"),n.createElement(u.cJ,null),'export * from "<module-path>.js"'),n.createElement(r.Z,null,'export  * from "./exported-module.js";'),n.createElement(o.Z,null,"If there are two or more wild-card export statements that implicitly",n.createElement(m.Z,null)," ",n.createElement(u.I,null,"re-exports")," the same name,",n.createElement(u.B,null,"neither one is re-exported"),"."),n.createElement(r.Z,null,'// "module-1.js"\nexport const a = 10;\n\n// "module-2.js"\nexport const a = 10;\n\n// "module-aggregator.js"\nexport * from "./module-1.js";\n\nexport * from "./module-2.js";\n'),n.createElement(r.Z,null,'// "main-program.js"\nimport * as md from "./module-aggregator.js";\nconsole.log(md.a);  // undefined\n'),n.createElement(o.Z,null,"Aggregator ",n.createElement(u.I,null,"re-exported")," the same member ",n.createElement(u.B,null,'"a"'),", therefore, it was not exported."))}},4691:(e,t,l)=>{l.r(t),l.d(t,{default:()=>c});var n=l(67294),r=l(81391),a=l(87398),o=l(68947),m=l(12050),u=l(9167);const c=function(){return n.createElement(n.Fragment,null,n.createElement(a.Z,{as:"h3"},"Default import"),n.createElement(o.Z,null,"As the name suggests, this is used to import the ",n.createElement(u.BI,null,"default export"),n.createElement(m.Z,null),"members.",n.createElement(m.Z,null),"members.",n.createElement(r.Z,null,'import greet from "./exportedModule.js";')),n.createElement(o.Z,null,"Importing a name called ",n.createElement(u.B,null,"default")," has the same effect as a",n.createElement(m.Z,null),n.createElement(u.I,null,"default import"),". It is necessary to alias the name because",n.createElement(m.Z,null),n.createElement(u.I,null,"default")," is a reserved word.",n.createElement(r.Z,null,'import { default as myDefaultMember } from "./module-1.js";')))}},74441:(e,t,l)=>{l.r(t),l.d(t,{default:()=>u});var n=l(67294),r=l(68947),a=l(12050),o=l(9167),m=[{label:"Named import"},{label:"Default import"},{label:"Namespace import"},{label:"Side-effect import"}];const u=function(){return n.createElement(n.Fragment,null,n.createElement(r.Z,null,"The ",n.createElement(o.I,null,"import")," declaration is used to import members which are exported from other modules. The imported members are ",n.createElement(o.I,null,"read-only"),n.createElement(a.Z,null),"with",n.createElement(a.Z,null),n.createElement(o.I,null,"live bindings"),", because the importing module cannot modify them, they are only updated by the source module which exported them."),n.createElement(r.Z,null,"In order to use the ",n.createElement(o.I,null,"import")," declaration, the file must be interpreted by the runtime as a ",n.createElement(o.I,null,"module"),". In HTML, this is done by adding the",n.createElement(o.BI,null,'type="module"')," attribute to the ",n.createElement(o.B,null,"<script>")," tag. There is also a function-like ",n.createElement(o.I,null,"dynamic import()"),", which does not require scripts of ",n.createElement(o.BI,null,'type="module"')," attribute."),n.createElement(r.Z,null,"There are four forms of import declaration:",n.createElement(o.GS,{unOrdered:!0,items:m})))}},49948:(e,t,l)=>{l.r(t),l.d(t,{default:()=>s});var n=l(67294),r=l(87398),a=l(68947),o=l(4691),m=l(74441),u=l(8744),c=l(15107),i=l(66984);const s=function(){return n.createElement(n.Fragment,null,n.createElement(r.Z,{as:"h2"},"import statement"),n.createElement(a.Z,null,n.createElement(m.default,null),n.createElement(u.default,null),n.createElement(o.default,null),n.createElement(c.default,null),n.createElement(i.default,null)))}},8744:(e,t,l)=>{l.r(t),l.d(t,{default:()=>c});var n=l(67294),r=l(81391),a=l(87398),o=l(68947),m=l(12050),u=l(9167);const c=function(){return n.createElement(n.Fragment,null,n.createElement(a.Z,{as:"h3"},"Named import"),n.createElement(o.Z,null,"As the name suggests, this is used to import the ",n.createElement(u.BI,null,"named export"),n.createElement(m.Z,null),"members.",n.createElement(r.Z,null,'import { sayHi, sayBye } from "./exportedModule.js";')))}},15107:(e,t,l)=>{l.r(t),l.d(t,{default:()=>s});var n=l(67294),r=l(81391),a=l(87398),o=l(26006),m=l(68947),u=l(12050),c=l(9167),i=l(33470);const s=function(){return n.createElement(n.Fragment,null,n.createElement(a.Z,{as:"h3"},"Namespace import"),n.createElement(m.Z,null,"Namespace import, inserts a given module into the current scope, containing all the exports from the module. All keys are ",n.createElement(u.Z,null),n.createElement(c.I,null,"enumerable")," in lexicographic order, with the",n.createElement(c.BI,null,"default export")," available as a key called",n.createElement(c.B,null,"default"),"."),n.createElement(r.Z,null,'import * as myModule from "./exportedModule.js";\nmyModule.greet(); // "Hello!"\n'),n.createElement(m.Z,null,n.createElement(c.BI,null,'"myModule"')," is a ",n.createElement(c.BI,null,"sealed")," object with a ",n.createElement(c.I,null,"null"),n.createElement(c.BI,null,"prototype"),"."),n.createElement(m.Z,null,"It is also possible to specify a ",n.createElement(c.I,null,"default import")," with the",n.createElement(u.Z,null),n.createElement(c.I,null,"namespace")," or",n.createElement(u.Z,null),n.createElement(c.I,null,"named import"),". In such cases, the ",n.createElement(c.I,null,"default import")," has to be declared before ",n.createElement(c.I,null,"namespace/named import"),"."),n.createElement(i.Z,{bold:!0,underline:!0},"Example of ",n.createElement(c.I,null,"default import")," with ",n.createElement(c.I,null,"namespace import"),"."),n.createElement(r.Z,null,'import defaultMember, * as myModule from "./exported-module.js";'),n.createElement(c.cJ,null),n.createElement(i.Z,{bold:!0,underline:!0},"Example of ",n.createElement(c.I,null,"default import")," with ",n.createElement(c.I,null,"named import"),"."),n.createElement(r.Z,null,'import defaultMember, { myExportedVal, myFunc } from "./exported-module.js";'),n.createElement(o.Z,null,"JavaScript do not have ",n.createElement(c.B,null,"wild-card import"),', like, import * from "exported-module.js", similar to wild-card export like export * from "module.js". The reason is the high possibility of name conflicts.'))}},66984:(e,t,l)=>{l.r(t),l.d(t,{default:()=>c});var n=l(67294),r=l(81391),a=l(87398),o=l(68947),m=l(12050),u=l(9167);const c=function(){return n.createElement(n.Fragment,null,n.createElement(a.Z,{as:"h3"},"Side-effect import"),n.createElement(o.Z,null,"This does not import anything from the module, instead the module is imported for ",n.createElement(u.I,null,"side-effects"),". As a ",n.createElement(u.I,null,"side-effect"),", this import declaration executes the imported module's code. This is often used for",n.createElement(m.Z,null),n.createElement(u.I,null,"polyfills"),", which mutate the global variables."),n.createElement(o.Z,null,n.createElement(u.IU,null,"Syntax:"),n.createElement(u.cJ,null),n.createElement(u.I,null,'import "<path-of-the-module>";')),n.createElement(r.Z,null,'import "./module.js";'))}},72233:(e,t,l)=>{l.r(t),l.d(t,{default:()=>a});var n=l(67294),r=l(68947);const a=function(){return n.createElement(n.Fragment,null,n.createElement(r.Z,null,"JavaScript programs started off with small usage, primarily to add interactivity to web pages. But, now we have complete web applications written in JavaScript. An application would need a gigantic size of code to be written and then loading that gigantic code will impact the performance, impacting the user experience. Therefore some mechanism was required for splitting JavaScript programs into separate modules that can be imported when needed."),n.createElement(r.Z,null,"Node.js has had this ability for a long time and there are a number of JavaScript libraries and frameworks that enable module usage. For example: CommonJs, RequireJs, Webpack, etc."),n.createElement(r.Z,null,"Modern browsers have started supporting module functionality natively, which means, browsers can optimize loading of modules, making it more efficient than having to use a library/framework to do all the required stuff. Use of native JavaScript modules is dependent on the import and export statement."))}},81116:(e,t,l)=>{l.r(t),l.d(t,{default:()=>d});var n=l(67294),r=l(9231),a=l(59044),o=l(87398),m=l(68947),u=l(68522),c=l(49948),i=l(72233),s=function(){return(0,r.Z)("UI-Geeks: JavaScript | Modules"),n.createElement(a.Z,null,n.createElement(o.Z,null,"JavaScript Modules"),n.createElement(m.Z,null,n.createElement(i.default,null),n.createElement(u.default,null),n.createElement(c.default,null)))};const d=(0,n.memo)(s)}}]);