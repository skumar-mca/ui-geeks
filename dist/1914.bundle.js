"use strict";(self.webpackChunkui_geeks_in=self.webpackChunkui_geeks_in||[]).push([[1914,5474],{31914:(e,l,n)=>{n.r(l),n.d(l,{default:()=>i});var t=n(67294),a=n(81391),r=n(68947),c=n(12050),u=n(9167),o=n(25474);const i=function(){return t.createElement(t.Fragment,null,t.createElement(r.Z,null,"A ",t.createElement(u.B,null,"closure")," is the ",t.createElement(u.BI,null,"combination")," of a",t.createElement(u.BI,null,"function bundled together")," (enclosed) with the references to its",t.createElement(u.B,null,"surrounding state")," (the ",t.createElement(u.B,null,"lexical")," ",t.createElement(c.Z,null),t.createElement(u.I,null,"environment variables"),"). In other words, a closure gives us access to an out function's scope from an inner function,",t.createElement(u.BI,null,"when the parent function has returned"),". In JavaScript closures are ",t.createElement(u.BI,null,"created every time a function is created"),"."),t.createElement(r.Z,null,"Let's learn about ",t.createElement(u.B,null,"Lexical Scope"),", in order to understand closures better."),t.createElement(r.Z,null,t.createElement(o.default,null)),t.createElement(r.Z,null,"Since we know about ",t.createElement(u.I,null,"lexical scope"),", now let's try to understand closures."),t.createElement(r.Z,null,"In closure, the ",t.createElement(u.I,null,"lexical environment")," consists of any local variables that were ",t.createElement(u.I,null,"in-scope")," at the time of closure creation. Let's try to understand this with the help of an example."),t.createElement(a.Z,null,"function makeAdder(x) {\n  return function(y) { return x + y; }\n}\n"),t.createElement(r.Z,null,t.createElement(u.B,null,"Lexical environment contains"),": variable ",t.createElement(u.B,null,"x")),t.createElement(a.Z,null,"const add5 = makeAdder(5);"),t.createElement(r.Z,null,"Because the ",t.createElement(u.BI,null,"makerAdder()")," function is returned, ",t.createElement(u.B,null,'"x"'),t.createElement(c.Z,null),'should have been gone, but since it formed closure, "x" is still available in ',t.createElement(u.BI,null,"lexical scope"),".",t.createElement(u.cJ,null),t.createElement(u.cJ,null),t.createElement(u.I,null,"The value of the lexical environment variable ",t.createElement(u.B,null,"x")," would be",t.createElement(u.B,null,"5"),".")),t.createElement(a.Z,null,"const add10 = makeAdder(10);"),t.createElement(r.Z,null,t.createElement(u.I,null,"The value of the lexical environment variable ",t.createElement(u.B,null,"x")," would be",t.createElement(u.B,null,"10"),".")),t.createElement(a.Z,null,"console.log(add5(2))\t// 7\nconsole.log(add10(2))\t// 12\n"),t.createElement(r.Z,null,"Both ",t.createElement(u.BI,null,"add5()")," and ",t.createElement(u.BI,null,"add10()")," are closures. They share the same function body definition, but store different lexical environments. In",t.createElement(u.BI,null,"add5()"),", lexical environment ",t.createElement(u.B,null,"x")," is 5, while in",t.createElement(u.B,null,"add10()")," it is 10."),t.createElement(r.Z,null,"In essence, ",t.createElement(u.BI,null,"makeAdder()")," is a ",t.createElement(u.B,null,"function factory"),". It creates functions that can add a specific value to their arguments."))}},25474:(e,l,n)=>{n.r(l),n.d(l,{default:()=>s});var t=n(67294),a=n(81391),r=n(87398),c=n(68947),u=n(12050),o=n(9167),i=[{label:t.createElement(t.Fragment,null,t.createElement(o.B,null,"Global Scope"),t.createElement(o.cJ,null),"Variables defined in global scope are available throughout the source code.")},{label:t.createElement(t.Fragment,null,t.createElement(o.B,null,"Function Scope"),t.createElement(o.cJ,null),"Variables defined in function scope are available in that function body only i.e they are local to that function.")},{label:t.createElement(t.Fragment,null,t.createElement(o.B,null,"Lexical Scope"),t.createElement(o.cJ,null),"This is also known as ",t.createElement(o.I,null,"block-scope")," and was introduced in",t.createElement(o.B,null,"ES6"),". Variables defined in lexical scope are available only within the enclosing block.")}];const s=function(){return t.createElement(t.Fragment,null,t.createElement(r.Z,{as:"h2"},"Lexical Scope"),t.createElement(c.Z,null,"The word ",t.createElement(o.B,null,'"lexical"')," refers to the fact that lexical scoping uses the ",t.createElement(o.B,null,"location")," where a variable is declared within the source code, to determine where that variable can be ",t.createElement(o.BI,null,"accessible"),"."),t.createElement(c.Z,null,"There are three types of scope in JavaScript:"),t.createElement(c.Z,null,t.createElement(o.GS,{expanded:!0,items:i})),t.createElement(c.Z,null,"In ES6, JavaScript introduced the",t.createElement(o.BI,null,"let")," and ",t.createElement(o.BI,null,"const"),t.createElement(u.Z,null)," keywords, which allows to create block-scoped variables."),t.createElement(a.Z,null,"if(true) { const x =1; }\nelse { const x = 2; }\nconsole.log(x);\t// ReferenceError"),t.createElement(c.Z,null,t.createElement(o.I,null,"The above statement gives ",t.createElement(o.B,null,"ReferenceError"),", because ",t.createElement(o.B,null,'"x"')," is a block-scoped variable and is not accessible here.")),t.createElement(c.Z,null,"In contrast to the above example, if we declare a variable using",t.createElement(o.BI,null,"var"),", it would create a ",t.createElement(o.I,null,"global scope")," and the variable should be available after the ",t.createElement(o.I,null,"if-else")," block."),t.createElement(a.Z,null,"if(true) { var x =1; }\nelse { var x = 2; }\nconsole.log(x);\t// 1"))}}}]);