"use strict";(self.webpackChunkui_geeks_in=self.webpackChunkui_geeks_in||[]).push([[868],{40868:(e,t,l)=>{l.r(t),l.d(t,{default:()=>m});var n=l(67294),a=l(81391),r=l(91573),i=l(87398),u=l(68947),o=l(12050),c=l(9167);const m=function(){return n.createElement(n.Fragment,null,n.createElement(i.Z,{as:"h4"},"Problem creating Closures in loop"),n.createElement(u.Z,null,"Prior to the introduction of the ",n.createElement(c.B,null,"let")," keyword, a common problem with closures occurred when closures were created inside a loop. Let's try to explore the problem and then understand the possible solutions."),n.createElement(a.Z,{language:r.r.HTML},'\x3c!-- HTML required for the example --\x3e\n<p id="help">Helpful notes will appear here<p>\n<p>Email: <input type="text" id="email" name="email" /> <p>\n<p>Name: <input type="textâ€ id="name" name="name" /> <p>\n<p>Age: <input type="text" id="age" name="age" /> <p>\n'),n.createElement(a.Z,null,'function getElement(id) { return document.getElementById(id); }\nfunction showHelp(help) { getElement("help").textContent = help; } \n\nvar helpText = [\n  { id: "email", help : "Your email address" },\n  { id: "name", help : "Your name" },\n  { id: "age", help : "Your age" },\n];\n\nfunction setupHelp() {\n  for(var i = 0; i< helpText.length; i++) {\n      var item  = helpText[i];\n      getElement(item.id).onfocus = function() { \n            showHelp(item.help);\n      }\n  }\n}\n\nsetupHelp();\n'),n.createElement(c.cJ,null),n.createElement(u.Z,null,"When the code runs, we'll see that no matter what field we ",n.createElement(c.I,null,"focus"),n.createElement(o.Z,null),"on, the help text of your ",n.createElement(c.B,null,'"age"')," is displayed. The reason for this is that the functions assigned to ",n.createElement(c.I,null,"onfocus")," are ",n.createElement(c.BI,null,"closures"),", they consist of the function definition and the captured lexical environment from the ",n.createElement(c.I,null,"setupHelp()")," ",n.createElement(o.Z,null),"function's scope. ",n.createElement(c.BI,null,"Three closures")," have been created by the loop, but each of them share the same lexical environment, which has a variable with changing values (",n.createElement(c.I,null,'"item"'),")."),n.createElement(u.Z,null,"Because the variable ",n.createElement(c.B,null,'"item"')," is declared with ",n.createElement(c.BI,null,"var"),", it has",n.createElement(o.Z,null),n.createElement(c.I,null,"function scope"),". The value of ",n.createElement(c.B,null,'"item.help"')," is determined when the ",n.createElement(c.I,null,"onfocus")," callbacks are executed. But, since the loop has already run its course by that time, the ",n.createElement(c.B,null,'"item"')," variable (shared by all closures) has been left pointing to the last entry in the",n.createElement(c.BI,null,"helpText")," array. Therefore, it will always display the",n.createElement(c.B,null,"last")," help text."),n.createElement(i.Z,{as:"h4"},"Solutions to the above problem"),n.createElement(u.Z,null,"Let's see possible solutions with and without ES6's ",n.createElement(c.BI,null,"let")," ","keyword."),n.createElement(u.Z,null,n.createElement(c.IU,null,"Solution 1:"),n.createElement(u.Z,null,"By creating more closures, in particular, by using a",n.createElement(c.BI,null,"function factory"),"."),n.createElement(a.Z,null,"function makeHelpCallback(help) {\n  return function() { showHelp(help); }\n}\n"),n.createElement(u.Z,null,"The ",n.createElement(c.BI,null,"makeHelpCallback()")," function creates a new"," ",n.createElement(c.I,null,"lexical environment")," for each callback, in which ",n.createElement(c.BI,null,'"help"')," ","refers to the corresponding item from the ",n.createElement(c.BI,null,"helpText")," array."),n.createElement(a.Z,null,"// Rewriting setupHelp to include the solution\nfunction setupHelp() {\n  for(var i = 0; i < helpText.length; i++) {\n    var item  = helpText[i];\n    getElement(item.id).onfocus = makeHelpCallback(item.help);\n  }\n}\n")),n.createElement(c.cJ,null),n.createElement(u.Z,null,n.createElement(c.IU,null,"Solution 2:"),n.createElement(u.Z,null,"By using ",n.createElement(c.I,null,"anonymous closures")," with the help of ",n.createElement(c.B,null,"IIFE"),n.createElement(o.Z,null)," (Immediately Invoked Function Expression)."),n.createElement(a.Z,null,"// Rewriting setupHelp to include the solution\nfunction setupHelp() {\n  for(var i = 0; i < helpText.length; i++) {\n    (function() {\n      var item  = helpText[i];\n      getElement(item.id).onfocus = function() {\n        showHelp(item.help);\n      }\n    })();\n  }\n}\n")),n.createElement(c.cJ,null),n.createElement(u.Z,null,n.createElement(c.IU,null,"Solution 3:"),n.createElement(u.Z,null,"By using ES6's ",n.createElement(c.BI,null,"let")," or ",n.createElement(c.BI,null,"const")," keyword. The use of",n.createElement(o.Z,null),n.createElement(c.I,null,"let"),n.createElement(o.Z,null),"or ",n.createElement(c.I,null,"const")," will create ",n.createElement(c.I,null,"block scope"),", hence fixing the problem."),n.createElement(a.Z,null,"// Rewriting setupHelp to include the solution\nfunction setupHelp(){\n  for(let i = 0; i< helpText.length; i++) {\n    let item  = helpText[i];\n    getElement(item.id).onfocus = () => {\n      showHelp(item.help);\n    }\n  }\n}\n")))}}}]);