"use strict";(self.webpackChunkui_geeks_in=self.webpackChunkui_geeks_in||[]).push([[9364,7761,9310,7319,2100,4389],{37761:(e,n,t)=>{t.r(n),t.d(n,{default:()=>i});var l=t(67294),a=t(81391),r=t(87398),c=t(68947),o=t(12050),u=t(9167),s=t(33470);const i=function(){return l.createElement(l.Fragment,null,l.createElement(r.Z,{as:"h4"},"Parsing Order"),l.createElement(c.Z,null,"Although the ",l.createElement(u.BI,null,"fat arrow")," ","(=>)"," in an arrow function is not an",l.createElement(u.BI,null,"operator"),", arrow functions have special parsing rules that interact differently with ",l.createElement(u.BI,null,"operator precedence")," compared to traditional functions."),l.createElement(a.Z,null,"let defaultFunc;\ndefaultFunc = defaultFunc || () => { };\n// SyntaxError: invalid arrow function arguments\n"),l.createElement(c.Z,null,"The ",l.createElement(u.B,null,"SyntaxError")," is because ","=>"," has a lower precedence than other operators."),l.createElement(c.Z,null,l.createElement(s.Z,{bold:!0,underline:!0},"Correct way"),l.createElement(o.Z,null),"would be:",l.createElement(u.cJ,null),"Parentheses are necessary to avoid",l.createElement(s.Z,{bold:!0,underline:!0},"defaultFunc || ()"),l.createElement(o.Z,null),"being parsed as the arguments of the arrow function.",l.createElement(a.Z,null,"let defaultFunc;\ndefaultFunc = defaultFunc || (() => { });\n")))}},49310:(e,n,t)=>{t.r(n),t.d(n,{default:()=>u});var l=t(67294),a=t(81391),r=t(87398),c=t(68947),o=t(9167);const u=function(){return l.createElement(l.Fragment,null,l.createElement(r.Z,{as:"h4"},'No binding of "arguments" object'),l.createElement(c.Z,null,"The",l.createElement(o.BI,null,"arguments")," is a reserved word which holds the list of arguments passed to the function. The arrow functions do not have their own",l.createElement(o.BI,null,"arguments")," object."),l.createElement(a.Z,null,'const show = () => arguments[0];\nshow();\t// "ReferenceError: arguments is not defined"'))}},57319:(e,n,t)=>{t.r(n),t.d(n,{default:()=>o});var l=t(67294),a=t(81391),r=t(87398),c=t(68947);const o=function(){return l.createElement(l.Fragment,null,l.createElement(r.Z,{as:"h4"},"Line breaks in arrow functions"),l.createElement(c.Z,null,"An arrow function cannot contain a line break between its parameters and its arrow."),l.createElement(a.Z,null,'const user = (name)\n\t=> "JavaScript";\n// This will give SyntaxError: Unexpected token "=>"\n'),l.createElement(c.Z,null,"However, line breaks can be added after the arrow or using parentheses."),l.createElement(a.Z,null,'const user = (name)\t=> \n"JavaScript";\n// Works fine\n'))}},22929:(e,n,t)=>{t.r(n),t.d(n,{default:()=>s});var l=t(67294),a=t(81391),r=t(26006),c=t(68947),o=t(12050),u=t(9167);const s=function(){return l.createElement(l.Fragment,null,l.createElement(c.Z,null,"In ",l.createElement(u.I,null,"arrow functions"),", ",l.createElement(u.BI,null,"this")," retains the value of the enclosing lexical context's ",l.createElement(u.BI,null,"this"),". In global code, ",l.createElement(u.BI,null,"this"),l.createElement(o.Z,null),"will be set to ",l.createElement(u.B,null,"global")," object."),l.createElement(c.Z,null,"An arrow function expression is a compact alternative to a traditional function expression, but is limited and can't be used in all situations."),l.createElement(c.Z,null,l.createElement(u.IU,null,"Syntax:"),l.createElement(u.cJ,null),l.createElement(u.B,null,"(arguments)"),l.createElement(u.B,null," => {"),l.createElement(u.cJ,null),l.createElement(u.Ai,null,"// statements"),l.createElement(u.cJ,null),"}"),l.createElement(c.Z,null,l.createElement(u.B,null,"arguments:")," Similar to traditional function, it is a list of input parameters passed to the function."),l.createElement(c.Z,null,"Operator ",l.createElement(u.B,null,"=>")," is also called ",l.createElement(u.BI,null,"Fat Arrow")," operator."),l.createElement(c.Z,null,l.createElement(u.IU,null,"Return value:"),l.createElement(u.cJ,null),"An arrow function returns the created function expression."),l.createElement(a.Z,null,"const sum = (num1, num2) => { \n  return num1 + num2;\n}\nsum(2, 5) // 7\n"),l.createElement(c.Z,null,"Below examples show how ",l.createElement(u.BI,null,"this")," refers to the lexical"," ",l.createElement(u.BI,null,"context's this"),".",l.createElement(a.Z,null,"var a = 100;\nconst obj = { \n  a:10, \n  show: () => { console.log(this.a); }\n};\nobj.show()  // 100\n"),l.createElement(c.Z,null,"Above code prints ",l.createElement(u.B,null,"100"),", because lexical context is the",l.createElement(u.BI,null,"global object"),", which has a variable named ",l.createElement(u.B,null,'"a"')," with value ",l.createElement(u.B,null,"100"),".")),l.createElement(c.Z,null,"But, if we use a traditional function, ",l.createElement(u.BI,null,"this")," will refer to the given object ",l.createElement(u.B,null,'"obj"'),".",l.createElement(a.Z,null,"var a = 100;\nconst obj = {\n  a:10,\n  show: function()  { console.log(this.a); }\n};\nobj.show()  // 10\n"),l.createElement(c.Z,null,"Above code prints ",l.createElement(u.B,null,"10"),", because ",l.createElement(u.BI,null,"this")," refers to the given object ",l.createElement(u.B,null,'"obj"'),".")),l.createElement(r.Z,null,"If ",l.createElement(u.B,null,"thisArg")," is passed to ",l.createElement(u.B,null,"call()"),", ",l.createElement(u.B,null,"bind()")," or",l.createElement(u.B,null,"apply()")," on invocation of an arrow function, it will be",l.createElement(u.B,null,"ignored"),". We can still ",l.createElement(u.B,null,"prepend arguments")," to the method, but the first argument ",l.createElement(u.B,null,"(thisArg)")," should be set to ",l.createElement(u.B,null,"null"),"."))}},99364:(e,n,t)=>{t.r(n),t.d(n,{default:()=>f});var l=t(67294),a=t(9231),r=t(59044),c=t(87398),o=t(68947),u=t(37761),s=t(49310),i=t(57319),m=t(22929),E=t(57492),h=t(32100),d=t(84389);const f=function(){return(0,a.Z)("UI-Geeks: JavaScript | Arrow functions"),l.createElement(r.Z,null,l.createElement(c.Z,null,"Arrow functions"),l.createElement(o.Z,null,l.createElement(m.default,null),l.createElement(h.default,null),l.createElement(E.default,null),l.createElement(s.default,null),l.createElement(d.default,null),l.createElement(i.default,null),l.createElement(u.default,null)))}},57492:(e,n,t)=>{t.r(n),t.d(n,{default:()=>i});var l=t(67294),a=t(81391),r=t(87398),c=t(26006),o=t(68947),u=t(12050),s=t(9167);const i=function(){return l.createElement(l.Fragment,null,l.createElement(r.Z,{as:"h4"},"Arrow functions as class fields"),l.createElement(o.Z,null,"A class's body has ",l.createElement(s.BI,null,"this")," context, ",l.createElement(s.I,null,"arrow functions")," as",l.createElement(s.BI,null,"class fields")," uses the class's ",l.createElement(s.BI,null,"this")," context and",l.createElement(s.BI,null,"this")," inside arrow function will point to the ",l.createElement(s.I,null,"instance"),". However, because it created a ",l.createElement(s.I,null,"closure"),", not the function's",l.createElement(u.Z,null),l.createElement(s.I,null,"own binding"),", the value of ",l.createElement(s.BI,null,"this")," will not change based on the execution context."),l.createElement(a.Z,null,'class User {\n  name = "JavaScript";\n  showName = ()=> { console.log(this.name); }\n}\n\nconst user = new User();\nuser.showName() //  "JavaScript"\n'),l.createElement(o.Z,null,l.createElement(s.B,null,'"JavaScript"')," was printed on console, because ",l.createElement(s.BI,null,"this.name")," ","refers to the class context."),l.createElement(o.Z,null,"Now let's try to change the context of ",l.createElement(s.B,null,"this"),"."),l.createElement(a.Z,null,'class User {\n  name = "JavaScript";\n  showName = ()=> { console.log(this.name); }\n}\n\nconst user = new User();\nconst { showName } = user;  // Breaking clas context here\nshowName()  // "JavaScript"'),l.createElement(o.Z,null,"Still ",l.createElement(s.B,null,'"JavaScript"')," was printed on console, because the class's arrow function always refers to ",l.createElement(s.BI,null,"this")," of the class, which",l.createElement(s.BI,null,"never changes"),". Therefore ",l.createElement(s.B,null,'"JavaScript"')," was printed on the console, otherwise undefined should have been printed."),l.createElement(o.Z,null,"Because the class's arrow function always refers to ",l.createElement(s.BI,null,"this")," of the class, which ",l.createElement(s.B,null,"never changes"),", arrow functions are often said to be",l.createElement(s.B,null,'"auto-bound methods"'),"."),l.createElement(r.Z,{as:"h4"},"Arrow function not to be used with call, apply and bind"),l.createElement(o.Z,null,"The ",l.createElement(s.BI,null,"call()"),", ",l.createElement(s.BI,null,"apply()")," and ",l.createElement(s.BI,null,"bind()")," methods are not suitable as arrow functions, as these methods were designed to allow methods to execute with ",l.createElement(s.B,null,"different scopes"),", but arrow functions on the other hand establish",l.createElement(s.BI,null,"this")," only based on the scope of the context in which the arrow function is defined."),l.createElement(a.Z,null,"const obj = { a: 10 };\nvar a = 100;\nconst sum = (num1, num2) => this.a + num1 + num2;\n\nsum.call(obj, 5, 50);\t// 155\n//Because:  100 +    5   +  50 = 155\n//     \t    this.a  num1    num2\n"),l.createElement(o.Z,null,"Although the expected result was ",l.createElement(s.B,null,"65")," ( 10 + 5 + 50), we got",l.createElement(s.B,null,"155"),", proving that arrow functions point ",l.createElement(s.BI,null,"this")," to the enclosing scope, which is the ",l.createElement(s.BI,null,"window")," here."),l.createElement(o.Z,null,"Same behavior is observed with ",l.createElement(s.BI,null,"bind()")," and ",l.createElement(s.BI,null,"apply()"),l.createElement(u.Z,null),"methods."),l.createElement(c.Z,null,"Class fields are defined on the ",l.createElement(s.B,null,"instance"),", not on the",l.createElement(s.B,null,"prototype"),", so every instance creation would create a new function reference and allocate a new closure, potentially leading to more memory usage than a normal unbound method."))}},32100:(e,n,t)=>{t.r(n),t.d(n,{default:()=>m});var l=t(67294),a=t(81391),r=t(87398),c=t(68947),o=t(9167),u=[{label:l.createElement(l.Fragment,null,"Arrow functions don't have their own bindings to",l.createElement(o.BI,null,"this"),", ",l.createElement(o.BI,null,"arguments")," or",l.createElement(o.BI,null,"super"),".")},{label:l.createElement(l.Fragment,null,"Arrow functions don't have access to the ",l.createElement(o.BI,null,"new.target")," keyword.")},{label:l.createElement(l.Fragment,null,"Arrow functions aren't suitable for ",l.createElement(o.BI,null,"call"),", ",l.createElement(o.BI,null,"apply")," and",l.createElement(o.BI,null,"bind")," methods, which generally rely on establishing a scope.")},{label:l.createElement(l.Fragment,null,"Arrow functions can't be used as ",l.createElement(o.BI,null,"constructors"),", it will throw an error when used with the ",l.createElement(o.BI,null,"new")," keyword.")},{label:l.createElement(l.Fragment,null,"Arrow functions can't use ",l.createElement(o.BI,null,"yield"),", within its body.")},{label:l.createElement(l.Fragment,null,"Arrow functions do not have a ",l.createElement(o.BI,null,"prototype")," property.")}],s=[{label:l.createElement(l.Fragment,null,"The ",l.createElement(o.I,null,"parentheses")," are ",l.createElement(o.B,null,"removed")," around the argument",l.createElement(o.B,null,'"num"'),", parentheses can be removed if the function has",l.createElement(o.BI,null,"only one argument"),".")},{label:l.createElement(l.Fragment,null,"The ",l.createElement(o.I,null,"return")," statement is ",l.createElement(o.B,null,"removed"),", this can be done if the function contains ",l.createElement(o.BI,null,"only one statement"),".")}],i=[{label:l.createElement(l.Fragment,null,"If the arrow function has ",l.createElement(o.B,null,"more than one argument"),".")},{label:l.createElement(l.Fragment,null,l.createElement(o.B,null,"Rest parameters")," always require parentheses.",l.createElement(o.cJ,null),l.createElement(o.I,null,"(a, b, …obj) => expression"))},{label:l.createElement(l.Fragment,null,l.createElement(o.B,null,"Default parameters")," always require parentheses.",l.createElement(o.cJ,null),l.createElement(o.I,null,"(a = 10, b = 5, c ) => expression"))}];const m=function(){return l.createElement(l.Fragment,null,l.createElement(r.Z,{as:"h4"},"Limitations of Arrow function"),l.createElement(c.Z,null,"There are some limitations with arrow function as compared to traditional function:"),l.createElement(c.Z,null,"An arrow function expression is a compact alternative to a traditional function expression, but is limited and can't be used in all situations."),l.createElement(o.GS,{expanded:!0,items:u}),l.createElement(o.cJ,null),l.createElement(c.Z,null,"Let's see how we can decompose traditional functions to arrow functions.",l.createElement(a.Z,null,"// Traditional function\nfunction isEven(num) {\n  return num % 2 === 0;\n}\n")),l.createElement(c.Z,null,"Equivalent arrow function of above traditional function.",l.createElement(a.Z,null,"const isEven = (num) => {\n  return num % 2 === 0\n};"),"Above compact alternative is known as",l.createElement(o.B,null,"arrow function with block body"),"."),l.createElement(c.Z,null,"We can further decompose the above arrow function. Below given compact alternative is known as the ",l.createElement(o.B,null,"arrow function with a concise body"),"."),l.createElement(a.Z,null,"const isEven = num => num % 2 === 0;"),l.createElement(c.Z,null,"Below changes were made to make it more concise:",l.createElement(o.GS,{unOrdered:!0,expanded:!0,items:s})),l.createElement(c.Z,null,"Parentheses around arguments ",l.createElement(o.B,null,"cannot")," be removed for below cases:",l.createElement(o.GS,{unOrdered:!0,expanded:!0,items:i})))}},84389:(e,n,t)=>{t.r(n),t.d(n,{default:()=>i});var l=t(67294),a=t(81391),r=t(87398),c=t(68947),o=t(12050),u=t(9167),s=t(33470);const i=function(){return l.createElement(l.Fragment,null,l.createElement(r.Z,{as:"h4"},'Returning "Object Literals"'),l.createElement(c.Z,null,"Returning ",l.createElement(u.BI,null,"object literals")," from arrow functions with a",l.createElement(u.BI,null,"concise body")," will not work as expected."),l.createElement(a.Z,null,'const user = () => { name : "JavaScript" };\nuser();   // undefined\n'),l.createElement(c.Z,null,"Because code inside curly braces (",") is",l.createElement(u.BI,null,"parsed as a sequence of statements")," (i.e., ",l.createElement(u.I,null,'"name"')," is treated like a ",l.createElement(u.BI,null,"label")," and not as a ",l.createElement(u.BI,null,"key")," in object literal)."),l.createElement(c.Z,null,l.createElement(s.Z,{bold:!0,underline:!0},"Correct way"),l.createElement(o.Z,null),"to return object literal would be:",l.createElement(a.Z,null,'const user = () => ({ name : "JavaScript" });')))}}}]);