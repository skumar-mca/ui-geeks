"use strict";(self.webpackChunkui_geeks_in=self.webpackChunkui_geeks_in||[]).push([[4156],{84156:(e,t,n)=>{n.r(t),n.d(t,{default:()=>i});var l=n(67294),r=n(81391),a=n(87398),o=n(68947),u=n(12050),c=n(9167);const i=function(){return l.createElement(l.Fragment,null,l.createElement(a.Z,{as:"h2"},"Iterables"),l.createElement(o.Z,null,"An ",l.createElement(c.I,null,"object")," is ",l.createElement(c.BI,null,"iterable"),", if it defines its iteration behavior. In order to be ",l.createElement(c.I,null,"iterable"),", an ",l.createElement(c.I,null,"object")," must implement the ",l.createElement(c.BI,null,"@@iterator")," method. This means that the",l.createElement(u.Z,null)," ",l.createElement(c.I,null,"object")," must have a property with a",l.createElement(c.BI,null,"Symbol.iterator")," ",l.createElement(c.I,null,"key"),". It may be possible to iterate over an iterable more than once or only once."),l.createElement(o.Z,null,l.createElement(c.BI,null,"Iterables")," which can iterate ",l.createElement(c.B,null,"only once")," (such as ",l.createElement(u.Z,null),l.createElement(c.I,null,"Generators"),") return ",l.createElement(c.BI,null,"this")," from their ",l.createElement(c.BI,null,"@@iterator"),l.createElement(u.Z,null)," method, whereas ",l.createElement(c.BI,null,"iterables")," which can be iterated",l.createElement(c.B,null,"many times")," must return a ",l.createElement(c.BI,null,"new iterator")," on each invocation of ",l.createElement(c.BI,null,"@@iterator"),"."),l.createElement(o.Z,null,l.createElement(c.IU,null,"Example 1:"),l.createElement(c.cJ,null),"Implementing an ",l.createElement(c.I,null,"iterable")," which can iterate ",l.createElement(c.B,null,"only once"),"."),l.createElement(o.Z,null,l.createElement(o.Z,null,"In below code, statement ",l.createElement(c.BI,null,"it[Symbol.iterator]() === it"),l.createElement(u.Z,null)," returned ",l.createElement(c.B,null,"true"),", i.e., ",l.createElement(c.I,null,"@@iterator")," method is returning itself, which shows this iterate only once."),l.createElement(r.Z,null,"function* makeIterator() {\n  yield 1;\n  yield 2;\n}\nconst it = makeIterator();\n\nfor(const itm of it) { console.log(itm); }\n// Output:\n// 1\n// 2\nit[Symbol.iterator]() === it;  // true\n"),l.createElement(o.Z,null,"Also, If we try to replicate the",l.createElement(c.BI,null,"for…of loop"),", it will not print in the console again, proving that it only iterates once."),l.createElement(r.Z,null,"const it = makeIterator();\nfor(const itm of it) { console.log(itm); }\n// Output:\n// 1\n// 2\n\nfor(const itm of it) { console.log(itm); }\n// Not output on console\n")),l.createElement(o.Z,null,l.createElement(c.IU,null,"Example 2:"),l.createElement(c.cJ,null),"Implementing an ",l.createElement(c.I,null,"iterable")," which can iterate ",l.createElement(c.B,null,"many times"),".",l.createElement(r.Z,null,"function* makeIterator() {\n  yield 1;\n  yield 2;\n}\n\nconst it = makeIterator();\nit[Symbol.iterator] = function*() {\n  yield 1;\n  yield 2;\n}\n\nfor(const itm of it) { \tconsole.log(itm); }\n// Output:\n// 1\n// 2\n\nfor(const itm of it) { \tconsole.log(itm); }\n// Output:\n// 1\n// 2\n"),l.createElement(o.Z,null,"In above code, both ",l.createElement(c.BI,null,"for…of")," loop printed numbers on the console, proving that it can iterate many times.")),l.createElement(o.Z,null,l.createElement(c.B,null,"next()"),": The ",l.createElement(c.I,null,"next()")," method also accepts a parameter value, which can be used to modify the internal state of the generator. A value passed to ",l.createElement(c.I,null,"next()")," will be received by ",l.createElement(c.BI,null,"yield"),". A value passed to the ",l.createElement(c.B,null,"first invocation")," of ",l.createElement(c.I,null,"next()")," is always ignored."),l.createElement(o.Z,null,l.createElement(c.IU,null,"Exmaple:"),l.createElement(r.Z,null,"function* fibonacci() {\n  let current = 0;\n  let next = 1;\n  while(true) {\n    const reset = yield current;\n    // Value passed to next() will be read here by yield current.\n\n    [current, next] = [next, next + current];\n    if(reset) {\n      current = 0;\n      next = 1;\n    }\n  }\t\n}\n\nconst sequence = fibonacci();\nsequence.next()\nconsole.log(sequence.next().value);  // 1\nsequence.next()\nconsole.log(sequence.next().value);  // 2\nsequence.next()\nconsole.log(sequence.next().value);  // 5\nsequence.next(true);  // Resetting here\nconsole.log(sequence.next().value);  // 1\n")),l.createElement(o.Z,null,l.createElement(c.B,null,"return()")," : Generators have a ",l.createElement(c.BI,null,"return(value)"),l.createElement(u.Z,null)," method that returns the given value and finishes the generator itself, and allows the generator to perform any cleanup tasks when combined with ",l.createElement(c.BI,null,"try…finally block"),". If the ",l.createElement(c.BI,null,"yield"),l.createElement(u.Z,null)," expression is wrapped in a ",l.createElement(c.I,null,"try…finally")," block, the control flow doesn't exit the ",l.createElement(c.I,null,"function body"),", but proceeds to the",l.createElement(c.I,null,"finally")," block instead."),l.createElement(o.Z,null,l.createElement(c.IU,null,"Example:"),l.createElement(c.cJ,null),l.createElement(r.Z,null,'function* generatorFunc() {\n  yield 1;\n  yield 2;\n}\n\nconst g = generatorFunc();\ng.next(); // { value: 1, dne: false }\n\ng.return("return value"); // { value: "return value", done: true }\n// Finishes the generator and returns the value passed to return() method.\n'),l.createElement(o.Z,null,"Below code finishes the generator and returns the value passed to return() method.",l.createElement(r.Z,null,'g.return("return value");\n// { value: "return value", done: true }')),l.createElement(o.Z,null,"Because generator was terminated by ",l.createElement(c.BI,null,'g.return("return value")'),l.createElement(u.Z,null)," statement. Now, if we call ",l.createElement(c.I,null,"next()")," methods, we'll get"," ",l.createElement(c.I,null,"value")," as ",l.createElement(c.BI,null,"undefined"),"."),l.createElement(r.Z,null,"g.next();\t\n// { value: undefined, done: true }")))}}}]);