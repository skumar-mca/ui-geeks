"use strict";(self.webpackChunkui_geeks_in=self.webpackChunkui_geeks_in||[]).push([[2100],{32100:(e,n,t)=>{t.r(n),t.d(n,{default:()=>s});var l=t(67294),a=t(81391),r=t(87398),o=t(68947),c=t(9167),u=[{label:l.createElement(l.Fragment,null,"Arrow functions don't have their own bindings to",l.createElement(c.BI,null,"this"),", ",l.createElement(c.BI,null,"arguments")," or",l.createElement(c.BI,null,"super"),".")},{label:l.createElement(l.Fragment,null,"Arrow functions don't have access to the ",l.createElement(c.BI,null,"new.target")," keyword.")},{label:l.createElement(l.Fragment,null,"Arrow functions aren't suitable for ",l.createElement(c.BI,null,"call"),", ",l.createElement(c.BI,null,"apply")," and",l.createElement(c.BI,null,"bind")," methods, which generally rely on establishing a scope.")},{label:l.createElement(l.Fragment,null,"Arrow functions can't be used as ",l.createElement(c.BI,null,"constructors"),", it will throw an error when used with the ",l.createElement(c.BI,null,"new")," keyword.")},{label:l.createElement(l.Fragment,null,"Arrow functions can't use ",l.createElement(c.BI,null,"yield"),", within its body.")},{label:l.createElement(l.Fragment,null,"Arrow functions do not have a ",l.createElement(c.BI,null,"prototype")," property.")}],m=[{label:l.createElement(l.Fragment,null,"The ",l.createElement(c.I,null,"parentheses")," are ",l.createElement(c.B,null,"removed")," around the argument",l.createElement(c.B,null,'"num"'),", parentheses can be removed if the function has",l.createElement(c.BI,null,"only one argument"),".")},{label:l.createElement(l.Fragment,null,"The ",l.createElement(c.I,null,"return")," statement is ",l.createElement(c.B,null,"removed"),", this can be done if the function contains ",l.createElement(c.BI,null,"only one statement"),".")}],i=[{label:l.createElement(l.Fragment,null,"If the arrow function has ",l.createElement(c.B,null,"more than one argument"),".")},{label:l.createElement(l.Fragment,null,l.createElement(c.B,null,"Rest parameters")," always require parentheses.",l.createElement(c.cJ,null),l.createElement(c.I,null,"(a, b, â€¦obj) => expression"))},{label:l.createElement(l.Fragment,null,l.createElement(c.B,null,"Default parameters")," always require parentheses.",l.createElement(c.cJ,null),l.createElement(c.I,null,"(a = 10, b = 5, c ) => expression"))}];const s=function(){return l.createElement(l.Fragment,null,l.createElement(r.Z,{as:"h4"},"Limitations of Arrow function"),l.createElement(o.Z,null,"There are some limitations with arrow function as compared to traditional function:"),l.createElement(o.Z,null,"An arrow function expression is a compact alternative to a traditional function expression, but is limited and can't be used in all situations."),l.createElement(c.GS,{expanded:!0,items:u}),l.createElement(c.cJ,null),l.createElement(o.Z,null,"Let's see how we can decompose traditional functions to arrow functions.",l.createElement(a.Z,null,"// Traditional function\nfunction isEven(num) {\n  return num % 2 === 0;\n}\n")),l.createElement(o.Z,null,"Equivalent arrow function of above traditional function.",l.createElement(a.Z,null,"const isEven = (num) => {\n  return num % 2 === 0\n};"),"Above compact alternative is known as",l.createElement(c.B,null,"arrow function with block body"),"."),l.createElement(o.Z,null,"We can further decompose the above arrow function. Below given compact alternative is known as the ",l.createElement(c.B,null,"arrow function with a concise body"),"."),l.createElement(a.Z,null,"const isEven = num => num % 2 === 0;"),l.createElement(o.Z,null,"Below changes were made to make it more concise:",l.createElement(c.GS,{unOrdered:!0,expanded:!0,items:m})),l.createElement(o.Z,null,"Parentheses around arguments ",l.createElement(c.B,null,"cannot")," be removed for below cases:",l.createElement(c.GS,{unOrdered:!0,expanded:!0,items:i})))}}}]);