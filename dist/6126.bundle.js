"use strict";(self.webpackChunkui_geeks_in=self.webpackChunkui_geeks_in||[]).push([[6126],{38191:(e,r,n)=>{n.r(r),n.d(r,{default:()=>E});var t=n(67294),l=n(9231),a=n(81391),o=n(91573),c=n(59044),s=n(87398),u=n(26006),i=n(68947),m=n(12050),d=n(9167),h=[{label:"Event Handlers"},{label:"Asynchronous code (like setTimeout)"},{label:"Server side rendering"},{label:"Error thrown in the error boundary itself"}];const E=function(){return(0,l.Z)("UI-Geeks: React | Error Boundaries"),t.createElement(c.Z,null,t.createElement(s.Z,null,"Error Boundaries"),t.createElement(i.Z,null,"A JavaScript error in a part of the UI shouldn't break the whole application. To solve this problem, React 16 introduced the concept of an ",t.createElement(d.B,null,'"error boundary"'),"."),t.createElement(i.Z,null,"Error boundaries are React components that ",t.createElement(m.Z,null),t.createElement(d.B,null,"catch JavaScript errors")," anywhere in their child component tree,",t.createElement(d.B,null,"log those errors"),", and ",t.createElement(d.B,null,"display a fallback UI")," instead of the component tree that crashed. Error boundaries catch errors during",t.createElement(d.I,null,"rendering"),", in ",t.createElement(d.I,null,"lifecycle methods"),", and in ",t.createElement(m.Z,null),t.createElement(d.I,null,"constructors")," of the whole tree below them."),t.createElement(i.Z,null,"Error boundaries do NOT catch errors for:",t.createElement(d.GS,{unOrdered:!0,items:h})),t.createElement(i.Z,null,"A ",t.createElement(d.B,null,"class component")," becomes an ",t.createElement(d.B,null,"error boundary")," if it defines either (or both) of the lifecycle methods ",t.createElement(m.Z,null),t.createElement(d.BI,null,"static getDerivedStateFromError()")," or ",t.createElement(m.Z,null),t.createElement(d.BI,null,"componentDidCatch()"),". Use ",t.createElement(m.Z,null),t.createElement(d.I,null,"static getDerivedStateFromError()")," to render fallback UI after an error and use ",t.createElement(d.I,null,"componentDidCatch()")," to log error information."),t.createElement(u.Z,null,"Only ",t.createElement(d.B,null,"class components")," can be used as Error Boundary, since function components do not have any hook for catching errors."),t.createElement(i.Z,null,t.createElement(d.IU,null,"Example:"),t.createElement(a.Z,{language:o.r.JSX},'class ErrorBoundary extends React.Component {\n    constructor(props) { \n        super(props);\n        this.state = { hasError : false };\n    }\n\n    static getDerivedStateFromError(error) {\n        // Update state so the next render will show the fallback UI\n        return { hasError : true };\n    }\n\n    componentDidCatch(error, info) {\n        // Example "componentStack"\n        // in ComponentThatThrows (created by App)\n        // in ErrorBoundary (created by App)\n        // in div (created by App)\n        // in App\n        logError(info.componentStack);\n    }\n\n    render() {\n        if(this.state.hasError) {\n            // Render any fallback UI for error handling\n            return <h1>Something went wrong.</h1>\n        }\n\n        return this.props.children;\n    }\n}\n')),t.createElement(i.Z,null,"Error Boundary can be used as a regular component wrapping the child components."),t.createElement(i.Z,null,t.createElement(a.Z,{language:o.r.JSX},"<ErrorBoundary>\n    <App />\n</ErrorBoundary>")))}}}]);