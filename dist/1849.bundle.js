"use strict";(self.webpackChunkui_geeks_in=self.webpackChunkui_geeks_in||[]).push([[1849,5262,868,1914,8755,5474],{15262:(e,t,l)=>{l.r(t),l.d(t,{default:()=>s});var n=l(67294),a=l(81391),r=l(87398),c=l(68947),o=l(12050),u=l(9167),i=[{label:n.createElement(n.Fragment,null,n.createElement(u.B,null,"Local Scope")," (Own scope)")},{label:n.createElement(n.Fragment,null,n.createElement(u.B,null,"Enclosing Scope")," (Can be block, function or module scope)")},{label:n.createElement(u.B,null,"Global Scope")}];const s=function(){return n.createElement(n.Fragment,null,n.createElement(r.Z,{as:"h3"},"Closure Scope Chain"),n.createElement(c.Z,null,"Every closure has three scopes:",n.createElement(u.GS,{items:i})),n.createElement(c.Z,null,"When nested functions themselves contain nested functions, this effectively creates a chain of function scopes."),n.createElement(a.Z,null,"const globalVal = 10; // Global Scope\nfunction sum(a) {\n  // outer scope\n  return function(b) {\n    // outer scope\n    return function(c){\n      // local scope\n      return a + b + c + globalVal;\n    }\n  }\n}\n\nconst result = sum(1)(2)(3);\nconsole.log(result)\t// 16"),n.createElement(c.Z,null,"There's a series of nested functions, all of which have access to the outer scope. In this context, it can be said that closures have access to all outer function scopes."),n.createElement(c.Z,null,"Closures can access members in ",n.createElement(u.BI,null,"module scope")," too. We'll learn about ",n.createElement(u.B,null,"modules")," in later sections, but for now, let's just try to understand module scope with closures."),n.createElement(a.Z,null,"// my-module.js\nlet x = 5;\nexport const getX = () => x;\nexport const setX = (val) => { x = val; };\n"),n.createElement(c.Z,null,"Here, the module ",n.createElement(u.I,null,"exports")," a pair of ",n.createElement(u.I,null,"getter-setter"),n.createElement(o.Z,null),"functions, which close over the module-scoped variable ",n.createElement(u.B,null,'"x"'),". Even when ",n.createElement(u.B,null,'"x"')," is not directly accessible from other modules, it can be read/written with the help of exported functions."),n.createElement(a.Z,null,'import { getX, setX } from "./my-module.js";\nconsole.log(getX()) // 5\nsetX(6);\nconsole.log(getX()) // 6'),n.createElement(c.Z,null,"Closures can close over imported values as well, which are regarded as",n.createElement(u.B,null,'"live bindings"'),", because when the original value changes, the imported members changes automatically."),n.createElement(a.Z,null,"// my-module.js\nexport let x =1;\nYesexport const setX = (val) => { x = val; };\n"),n.createElement(a.Z,null,'// closure-creator.js\nimport { x } from "./my-module.js";\nexport const getX = () => x;\n// Live binding is created for variable "x"'),n.createElement(a.Z,null,'// main-program.js\nimport { getX } from "./closure-creator.js";\nimport { setX } from "./my-module.js";\nconsole.log(getX())\t// 1\nsetX(2);\nconsole.log(getX())\t// 2\n'),n.createElement(c.Z,null,n.createElement(u.BI,null,"setX(2);"),n.createElement(u.cJ,null),"Above statement updated the value of ",n.createElement(u.B,null,'"x"'),", placed in",n.createElement(o.Z,null),n.createElement(u.IU,null,"my-module.js"),", and at the same time updated the value of",n.createElement(u.B,null,'"x"')," in ",n.createElement(u.IU,null,"closure-creator.js")," with the help of",n.createElement(u.B,null,"live binding"),"."))}},40868:(e,t,l)=>{l.r(t),l.d(t,{default:()=>s});var n=l(67294),a=l(81391),r=l(91573),c=l(87398),o=l(68947),u=l(12050),i=l(9167);const s=function(){return n.createElement(n.Fragment,null,n.createElement(c.Z,{as:"h4"},"Problem creating Closures in loop"),n.createElement(o.Z,null,"Prior to the introduction of the ",n.createElement(i.B,null,"let")," keyword, a common problem with closures occurred when closures were created inside a loop. Let's try to explore the problem and then understand the possible solutions."),n.createElement(a.Z,{language:r.r.HTML},'\x3c!-- HTML required for the example --\x3e\n<p id="help">Helpful notes will appear here<p>\n<p>Email: <input type="text" id="email" name="email" /> <p>\n<p>Name: <input type="text” id="name" name="name" /> <p>\n<p>Age: <input type="text" id="age" name="age" /> <p>\n'),n.createElement(a.Z,null,'function getElement(id) { return document.getElementById(id); }\nfunction showHelp(help) { getElement("help").textContent = help; } \n\nvar helpText = [\n  { id: "email", help : "Your email address" },\n  { id: "name", help : "Your name" },\n  { id: "age", help : "Your age" },\n];\n\nfunction setupHelp() {\n  for(var i = 0; i< helpText.length; i++) {\n      var item  = helpText[i];\n      getElement(item.id).onfocus = function() { \n            showHelp(item.help);\n      }\n  }\n}\n\nsetupHelp();\n'),n.createElement(i.cJ,null),n.createElement(o.Z,null,"When the code runs, we'll see that no matter what field we ",n.createElement(i.I,null,"focus"),n.createElement(u.Z,null),"on, the help text of your ",n.createElement(i.B,null,'"age"')," is displayed. The reason for this is that the functions assigned to ",n.createElement(i.I,null,"onfocus")," are ",n.createElement(i.BI,null,"closures"),", they consist of the function definition and the captured lexical environment from the ",n.createElement(i.I,null,"setupHelp()")," ",n.createElement(u.Z,null),"function's scope. ",n.createElement(i.BI,null,"Three closures")," have been created by the loop, but each of them share the same lexical environment, which has a variable with changing values (",n.createElement(i.I,null,'"item"'),")."),n.createElement(o.Z,null,"Because the variable ",n.createElement(i.B,null,'"item"')," is declared with ",n.createElement(i.BI,null,"var"),", it has",n.createElement(u.Z,null),n.createElement(i.I,null,"function scope"),". The value of ",n.createElement(i.B,null,'"item.help"')," is determined when the ",n.createElement(i.I,null,"onfocus")," callbacks are executed. But, since the loop has already run its course by that time, the ",n.createElement(i.B,null,'"item"')," variable (shared by all closures) has been left pointing to the last entry in the",n.createElement(i.BI,null,"helpText")," array. Therefore, it will always display the",n.createElement(i.B,null,"last")," help text."),n.createElement(c.Z,{as:"h4"},"Solutions to the above problem"),n.createElement(o.Z,null,"Let's see possible solutions with and without ES6's ",n.createElement(i.BI,null,"let")," ","keyword."),n.createElement(o.Z,null,n.createElement(i.IU,null,"Solution 1:"),n.createElement(o.Z,null,"By creating more closures, in particular, by using a",n.createElement(i.BI,null,"function factory"),"."),n.createElement(a.Z,null,"function makeHelpCallback(help) {\n  return function() { showHelp(help); }\n}\n"),n.createElement(o.Z,null,"The ",n.createElement(i.BI,null,"makeHelpCallback()")," function creates a new"," ",n.createElement(i.I,null,"lexical environment")," for each callback, in which ",n.createElement(i.BI,null,'"help"')," ","refers to the corresponding item from the ",n.createElement(i.BI,null,"helpText")," array."),n.createElement(a.Z,null,"// Rewriting setupHelp to include the solution\nfunction setupHelp() {\n  for(var i = 0; i < helpText.length; i++) {\n    var item  = helpText[i];\n    getElement(item.id).onfocus = makeHelpCallback(item.help);\n  }\n}\n")),n.createElement(i.cJ,null),n.createElement(o.Z,null,n.createElement(i.IU,null,"Solution 2:"),n.createElement(o.Z,null,"By using ",n.createElement(i.I,null,"anonymous closures")," with the help of ",n.createElement(i.B,null,"IIFE"),n.createElement(u.Z,null)," (Immediately Invoked Function Expression)."),n.createElement(a.Z,null,"// Rewriting setupHelp to include the solution\nfunction setupHelp() {\n  for(var i = 0; i < helpText.length; i++) {\n    (function() {\n      var item  = helpText[i];\n      getElement(item.id).onfocus = function() {\n        showHelp(item.help);\n      }\n    })();\n  }\n}\n")),n.createElement(i.cJ,null),n.createElement(o.Z,null,n.createElement(i.IU,null,"Solution 3:"),n.createElement(o.Z,null,"By using ES6's ",n.createElement(i.BI,null,"let")," or ",n.createElement(i.BI,null,"const")," keyword. The use of",n.createElement(u.Z,null),n.createElement(i.I,null,"let"),n.createElement(u.Z,null),"or ",n.createElement(i.I,null,"const")," will create ",n.createElement(i.I,null,"block scope"),", hence fixing the problem."),n.createElement(a.Z,null,"// Rewriting setupHelp to include the solution\nfunction setupHelp(){\n  for(let i = 0; i< helpText.length; i++) {\n    let item  = helpText[i];\n    getElement(item.id).onfocus = () => {\n      showHelp(item.help);\n    }\n  }\n}\n")))}},31914:(e,t,l)=>{l.r(t),l.d(t,{default:()=>i});var n=l(67294),a=l(81391),r=l(68947),c=l(12050),o=l(9167),u=l(25474);const i=function(){return n.createElement(n.Fragment,null,n.createElement(r.Z,null,"A ",n.createElement(o.B,null,"closure")," is the ",n.createElement(o.BI,null,"combination")," of a",n.createElement(o.BI,null,"function bundled together")," (enclosed) with the references to its",n.createElement(o.B,null,"surrounding state")," (the ",n.createElement(o.B,null,"lexical")," ",n.createElement(c.Z,null),n.createElement(o.I,null,"environment variables"),"). In other words, a closure gives us access to an out function's scope from an inner function,",n.createElement(o.BI,null,"when the parent function has returned"),". In JavaScript closures are ",n.createElement(o.BI,null,"created every time a function is created"),"."),n.createElement(r.Z,null,"Let's learn about ",n.createElement(o.B,null,"Lexical Scope"),", in order to understand closures better."),n.createElement(r.Z,null,n.createElement(u.default,null)),n.createElement(r.Z,null,"Since we know about ",n.createElement(o.I,null,"lexical scope"),", now let's try to understand closures."),n.createElement(r.Z,null,"In closure, the ",n.createElement(o.I,null,"lexical environment")," consists of any local variables that were ",n.createElement(o.I,null,"in-scope")," at the time of closure creation. Let's try to understand this with the help of an example."),n.createElement(a.Z,null,"function makeAdder(x) {\n  return function(y) { return x + y; }\n}\n"),n.createElement(r.Z,null,n.createElement(o.B,null,"Lexical environment contains"),": variable ",n.createElement(o.B,null,"x")),n.createElement(a.Z,null,"const add5 = makeAdder(5);"),n.createElement(r.Z,null,"Because the ",n.createElement(o.BI,null,"makerAdder()")," function is returned, ",n.createElement(o.B,null,'"x"'),n.createElement(c.Z,null),'should have been gone, but since it formed closure, "x" is still available in ',n.createElement(o.BI,null,"lexical scope"),".",n.createElement(o.cJ,null),n.createElement(o.cJ,null),n.createElement(o.I,null,"The value of the lexical environment variable ",n.createElement(o.B,null,"x")," would be",n.createElement(o.B,null,"5"),".")),n.createElement(a.Z,null,"const add10 = makeAdder(10);"),n.createElement(r.Z,null,n.createElement(o.I,null,"The value of the lexical environment variable ",n.createElement(o.B,null,"x")," would be",n.createElement(o.B,null,"10"),".")),n.createElement(a.Z,null,"console.log(add5(2))\t// 7\nconsole.log(add10(2))\t// 12\n"),n.createElement(r.Z,null,"Both ",n.createElement(o.BI,null,"add5()")," and ",n.createElement(o.BI,null,"add10()")," are closures. They share the same function body definition, but store different lexical environments. In",n.createElement(o.BI,null,"add5()"),", lexical environment ",n.createElement(o.B,null,"x")," is 5, while in",n.createElement(o.B,null,"add10()")," it is 10."),n.createElement(r.Z,null,"In essence, ",n.createElement(o.BI,null,"makeAdder()")," is a ",n.createElement(o.B,null,"function factory"),". It creates functions that can add a specific value to their arguments."))}},78755:(e,t,l)=>{l.r(t),l.d(t,{default:()=>m});var n=l(67294),a=l(81391),r=l(87398),c=l(68947),o=l(12050),u=l(9167),i=[{label:n.createElement(n.Fragment,null,n.createElement(u.B,null,"increment()")," function")},{label:n.createElement(n.Fragment,null,n.createElement(u.B,null,"decrement()")," function")},{label:n.createElement(n.Fragment,null,n.createElement(u.B,null,"value()")," function")}],s=[{label:n.createElement(n.Fragment,null,n.createElement(u.B,null,"privateCtr")," variable")},{label:n.createElement(n.Fragment,null,n.createElement(u.B,null,"changeBy()")," function")}];const m=function(){return n.createElement(n.Fragment,null,n.createElement(c.Z,null,"One of the main use cases for closures is creating",n.createElement(u.BI,null,"private methods/properties")," in functions."),n.createElement(r.Z,{as:"h2"},"Creating private methods/properties using Closures"),n.createElement(c.Z,null,"JavaScript, prior to ",n.createElement(u.I,null,"classes"),", didn't have a native way of declaring private methods, but it was possible to emulate private methods using closures."),n.createElement(c.Z,null,"Let's try to understand with the help of an example:"),n.createElement(a.Z,null,"const makeCounter = function() {\n    // private members\n    let privateCtr = 0;\n    function changeBy(val) { privateCtr += val; }\n    // public members, returned from here\n    return {\n        increment() { changeBy(1); },\n        decrement() { changeBy(-1); },\n        value() { return privateCtr; }\n  }\n}\n\nconst counter = makeCounter();\ncounter.value();    // 0\ncounter.increment();\ncounter.value();    // 1\ncounter.decrement();\ncounter.value();    // 1"),n.createElement(u.cJ,null),n.createElement(c.Z,null,"The lexical environment contains two private members:",n.createElement(u.GS,{items:s})),n.createElement(c.Z,null,"The private members can't be accessed from outside the"," ",n.createElement(u.I,null,"makeCounter()")," ",n.createElement(o.Z,null),"function. Instead, public members should be used to access the private members."),n.createElement(c.Z,null,"Below are the public functions returned from ",n.createElement(u.I,null,"makeCounter()"),":",n.createElement(u.GS,{items:i})),n.createElement(c.Z,null,"Above public functions are closures that share the same lexical environment."))}},1849:(e,t,l)=>{l.r(t),l.d(t,{default:()=>E});var n=l(67294),a=l(9231),r=l(59044),c=l(87398),o=l(68947),u=l(15262),i=l(40868),s=l(31914),m=l(78755);const E=function(){return(0,a.Z)("UI-Geeks: JavaScript | Closures"),n.createElement(r.Z,null,n.createElement(c.Z,null,"Closures"),n.createElement(o.Z,null,n.createElement(s.default,null),n.createElement(m.default,null),n.createElement(u.default,null),n.createElement(i.default,null)))}},25474:(e,t,l)=>{l.r(t),l.d(t,{default:()=>s});var n=l(67294),a=l(81391),r=l(87398),c=l(68947),o=l(12050),u=l(9167),i=[{label:n.createElement(n.Fragment,null,n.createElement(u.B,null,"Global Scope"),n.createElement(u.cJ,null),"Variables defined in global scope are available throughout the source code.")},{label:n.createElement(n.Fragment,null,n.createElement(u.B,null,"Function Scope"),n.createElement(u.cJ,null),"Variables defined in function scope are available in that function body only i.e they are local to that function.")},{label:n.createElement(n.Fragment,null,n.createElement(u.B,null,"Lexical Scope"),n.createElement(u.cJ,null),"This is also known as ",n.createElement(u.I,null,"block-scope")," and was introduced in",n.createElement(u.B,null,"ES6"),". Variables defined in lexical scope are available only within the enclosing block.")}];const s=function(){return n.createElement(n.Fragment,null,n.createElement(r.Z,{as:"h2"},"Lexical Scope"),n.createElement(c.Z,null,"The word ",n.createElement(u.B,null,'"lexical"')," refers to the fact that lexical scoping uses the ",n.createElement(u.B,null,"location")," where a variable is declared within the source code, to determine where that variable can be ",n.createElement(u.BI,null,"accessible"),"."),n.createElement(c.Z,null,"There are three types of scope in JavaScript:"),n.createElement(c.Z,null,n.createElement(u.GS,{expanded:!0,items:i})),n.createElement(c.Z,null,"In ES6, JavaScript introduced the",n.createElement(u.BI,null,"let")," and ",n.createElement(u.BI,null,"const"),n.createElement(o.Z,null)," keywords, which allows to create block-scoped variables."),n.createElement(a.Z,null,"if(true) { const x =1; }\nelse { const x = 2; }\nconsole.log(x);\t// ReferenceError"),n.createElement(c.Z,null,n.createElement(u.I,null,"The above statement gives ",n.createElement(u.B,null,"ReferenceError"),", because ",n.createElement(u.B,null,'"x"')," is a block-scoped variable and is not accessible here.")),n.createElement(c.Z,null,"In contrast to the above example, if we declare a variable using",n.createElement(u.BI,null,"var"),", it would create a ",n.createElement(u.I,null,"global scope")," and the variable should be available after the ",n.createElement(u.I,null,"if-else")," block."),n.createElement(a.Z,null,"if(true) { var x =1; }\nelse { var x = 2; }\nconsole.log(x);\t// 1"))}}}]);