"use strict";(self.webpackChunkui_geeks_in=self.webpackChunkui_geeks_in||[]).push([[4193,6006,7893,6148,9045,6442,7075],{74193:(e,n,t)=>{t.r(n),t.d(n,{default:()=>o});var l=t(67294),a=t(81391),r=t(87398),i=t(26006),s=t(68947),c=t(12050),u=t(9167);const o=function(){return l.createElement(l.Fragment,null,l.createElement(r.Z,{as:"h4"},"bind()"),l.createElement(s.Z,null,"This method creates a new function that, when called, has it's",l.createElement(c.Z,null)," ",l.createElement(u.I,null,"this"),", set to the provided value, with the given arguments preceding any arguments provided when the new function is called."),l.createElement(s.Z,null,l.createElement(u.I,null,"Syntax:")),l.createElement(s.Z,null,"bind(",l.createElement(u.BI,null,"thisArg"),")",l.createElement(u.cJ,null),l.createElement(u.BI,null,"this")," will be replaced with ",l.createElement(u.BI,null,"thisArg"),"."),l.createElement(s.Z,null,"bind(",l.createElement(u.BI,null,"thisArg"),", arg1, arg2, â€¦, argN)",l.createElement(u.cJ,null),l.createElement(u.BI,null,"this")," will be replaced with ",l.createElement(u.BI,null,"thisArg")," and following",l.createElement(c.Z,null)," ",l.createElement(u.I,null,"arguments")," will be assigned to function ",l.createElement(u.I,null,"arguments"),"."),l.createElement(s.Z,null,l.createElement(u.I,null,"bind()")," is similar to ",l.createElement(u.BI,null,"call()"),", with a difference that",l.createElement(u.BI,null,"thisArg")," and ",l.createElement(u.BI,null,"arguments")," can't be reassigned i.e., it holds the values from the ",l.createElement(u.B,null,"first bind call"),"."),l.createElement(s.Z,null,"The ",l.createElement(u.I,null,"bind()")," method returns a copy of the given function with the specified ",l.createElement(u.BI,null,"this")," value and initial arguments (if provided)."),l.createElement(s.Z,null,"The ",l.createElement(u.I,null,"bind()")," function creates a ",l.createElement(u.I,null,"new bound function"),". Calling a ",l.createElement(u.I,null,"bound function")," generally results in the execution of its wrapper function. The bound function will store the parameters passed, which includes the value of ",l.createElement(u.I,null,"this")," and the arguments, as its internal state. These values are stored in advance, instead of being passed the time of calling function."),l.createElement(s.Z,null,"This concept is also called ",l.createElement(u.B,null,"Function Currying"),", where a function is created from an existing function, by presetting some of the parameters."),l.createElement(s.Z,null,l.createElement(u.IU,null,"Example 1:"),l.createElement(u.cJ,null),"In below example, the argument ",l.createElement(u.B,null,'"a"')," of the ",l.createElement(u.BI,null,"multiply()"),l.createElement(c.Z,null),"function is assigned the value ",l.createElement(u.B,null,"2")," in advance.",l.createElement(a.Z,null,"function multiply(a, b) { return a * b; }\nconst multiplyByTwo = multiply.bind(this, 2);\nconsole.log(multiplyByTwo(5));\t// 10")),l.createElement(u.cJ,null),l.createElement(s.Z,null,l.createElement(u.IU,null,"Example 2:"),l.createElement(u.cJ,null),"Similarly, in below example, the argument ",l.createElement(u.B,null,'"a"')," of the",l.createElement(u.BI,null,"multiply()"),l.createElement(c.Z,null),"function is assigned the value ",l.createElement(u.B,null,"3")," in advance.",l.createElement(a.Z,null,"function multiply(a, b) { return a * b; }\nconst multiplyByThree = multiply.bind(this, 3);\nconsole.log(multiplyByThree(10));\t// 30")),l.createElement(u.cJ,null),l.createElement(s.Z,null,l.createElement(u.IU,null,"Example 3:"),l.createElement(u.cJ,null),"Below example, demonstrates that binding can't be reassigned.",l.createElement(a.Z,null,"function sum(num1, num2) {\n  return this.a + this.b + num1 + num2;\n}\nconst obj = { a: 10, b : 20 };\nconst newSumFn = sum.bind(obj, 5, 15);\nconst res = newSumFn();\nconsole.log(res)  // 50\n\n// Passing fresh arguments here\nconst res1 = newSumFn(100, 200);\nconsole.log(res1) // 50\n// Still prints 50, fresh arguments were ignored. \n"),l.createElement(s.Z,null,"The value of ",l.createElement(u.BI,null,"res1")," was ",l.createElement(u.I,null,"50"),", because",l.createElement(u.BI,null,"arguments passed at the time of call")," were ignored. This proves that arguments can't be reassigned. Values given at the time of calling function are ignored here.")),l.createElement(s.Z,null,l.createElement(u.IU,null,"Example 4:"),l.createElement(u.cJ,null),l.createElement(a.Z,null,"function sum(num1, num2) {\n  return this.a + this.b + num1 + num2;\n}\nconst obj = { a: 10, b : 20 };\nconst newSumFn = sum.bind(obj, 5, 15);\nconst res = newSumFn();\nconsole.log(res)  // 50\n\nconst anotherObj = { a: 100, b: 200 };\nconst anotherSumFn = newSumFn(anotherObj, 500, 1000);\nconst res2 = anotherSumFn();\nconsole.log(res2) // 50"),l.createElement(s.Z,null,"The value of ",l.createElement(u.BI,null,"res2")," was ",l.createElement(u.I,null,"50"),", because",l.createElement(u.BI,null,"anotherObj")," passed as ",l.createElement(u.BI,null,"this")," at the time of call was ignored. This proves that ",l.createElement(u.BI,null,"this")," can't be reassigned. Values given at the time of calling function are ignored here. Also, observe that ",l.createElement(u.BI,null,"anotherSumFn")," was created from an earlier binded function",l.createElement(u.BI,null,"newSumFn")," ",l.createElement(c.Z,null)," and not ",l.createElement(u.BI,null,"sum"),".")),l.createElement(i.Z,null,"Original function can be bound multiple times. For example:",l.createElement(u.cJ,null),"const anotherSumFn = ",l.createElement(u.B,null,"sum.bind"),"(anotherObj, 500, 1000);",l.createElement(u.cJ,null),"const res2 = anotherSumFn();",l.createElement(u.cJ,null),"console.log(res2);  // 1800"))}},26006:(e,n,t)=>{t.d(n,{Z:()=>U});var l=t(4942),a=t(94184),r=t.n(a),i=t(67294),s=t(14289),c=t(78146),u=t(67115),o=t(76792),m=t(32209),h=t(41485),d=t(39602),E=t(44680),g=t(85893);const b=(0,d.Z)("h4");b.displayName="DivStyledAsH4";const f=(0,E.Z)("alert-heading",{Component:b}),p=(0,E.Z)("alert-link",{Component:u.Z}),w={variant:"primary",show:!0,transition:m.Z,closeLabel:"Close alert"},v=i.forwardRef(((e,n)=>{const{bsPrefix:t,show:l,closeLabel:a,closeVariant:i,className:u,children:d,variant:E,onClose:b,dismissible:f,transition:p,...w}=(0,s.Ch)(e,{show:"onClose"}),v=(0,o.vE)(t,"alert"),Z=(0,c.Z)((e=>{b&&b(!1,e)})),I=!0===p?m.Z:p,B=(0,g.jsxs)("div",{role:"alert",...I?void 0:w,ref:n,className:r()(u,v,E&&`${v}-${E}`,f&&`${v}-dismissible`),children:[f&&(0,g.jsx)(h.Z,{onClick:Z,"aria-label":a,variant:i}),d]});return I?(0,g.jsx)(I,{unmountOnExit:!0,...w,ref:void 0,in:l,children:B}):l?B:null}));v.displayName="Alert",v.defaultProps=w;const Z=Object.assign(v,{Link:p,Heading:f});var I=t(83819),B=t(93379),y=t.n(B),x=t(7795),S=t.n(x),T=t(90569),F=t.n(T),k=t(3565),j=t.n(k),C=t(19216),J=t.n(C),A=t(44589),N=t.n(A),O=t(11137),L={};L.styleTagTransform=N(),L.setAttributes=j(),L.insert=F().bind(null,"head"),L.domAPI=S(),L.insertStyleElement=J(),y()(O.Z,L),O.Z&&O.Z.locals&&O.Z.locals;var P=function(e){var n=e.children,t=e.noteText,a=void 0===t?"Note":t,s=e.variant,c=void 0===s?"primary":s,u=r()((0,l.Z)({},"".concat(I.HL,"-note"),!0));return i.createElement("div",{className:u},i.createElement("div",{className:"note-text"},a),i.createElement(Z,{key:c,variant:c},n))};const U=(0,i.memo)(P)},11137:(e,n,t)=>{t.d(n,{Z:()=>s});var l=t(8081),a=t.n(l),r=t(23645),i=t.n(r)()(a());i.push([e.id,".ui-geeks-note{margin-top:1.2rem;margin-bottom:3rem;font-style:italic}.ui-geeks-note .note-text{font-style:italic;position:relative;font-weight:bold;top:13px;z-index:9;margin-left:15px;background-color:#aba8f1;width:fit-content;padding:2px 10px 2px 10px;border-radius:4px}\n",""]);const s=i}}]);