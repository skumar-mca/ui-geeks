"use strict";(self.webpackChunkui_geeks_in=self.webpackChunkui_geeks_in||[]).push([[2943,3831,4931,505,6006,7298,7893,6148,7179,9045,6442,1939,537,1732,7075,3242,9745,651,6636],{91939:(e,t,n)=>{n.r(t),n.d(t,{default:()=>i});var l=n(67294),a=n(81391),r=n(91573),o=n(87398),c=n(68947),u=n(12050),s=n(9167);const i=function(){return l.createElement(l.Fragment,null,l.createElement(o.Z,{as:"h2"},"Default Values"),l.createElement(c.Z,null,"In the React rendering lifecycle, the ",l.createElement(s.BI,null,"value")," attribute on form elements will override the value in the DOM. With an ",l.createElement(u.Z,null),l.createElement(s.I,null,"uncontrolled component"),", we often want React to specify the",l.createElement(s.B,null,"initial value"),", but leave subsequent updates ",l.createElement(s.I,null,"uncontrolled"),". In such cases, we can add ",l.createElement(s.BI,null,"defaultValue")," attribute instead of",l.createElement(s.BI,null,"value"),". Changing the value of ",l.createElement(s.BI,null,"defaultValue")," after a component has mounted will not cause any update of the value in the DOM."),l.createElement(c.Z,null,"Similarly, ",l.createElement(s.B,null,"checkbox"),", ",l.createElement(s.B,null,"radio")," elements have ",l.createElement(u.Z,null),l.createElement(s.BI,null,"defaultChecked")," attributes."),l.createElement(a.Z,{language:r.r.JSX},'const DefaultValueComponent = () => {\n  const textInput = useRef();\n  const checkboxInput = useRef();\n\n  useEffect(() =>  {\n    textInput.current.focusTextInput();\n  },[ ]);\n\n  return <div>\n    <input type="text"\n      ref={this.textInput}\n      defaultValue="Hello" />\n\n    <input type="checkbox"\n      ref={this.checkboxInput} \n      defaultChecked={true} />\n  </div>\n}'))}},537:(e,t,n)=>{n.r(t),n.d(t,{default:()=>m});var l=n(67294),a=n(81391),r=n(91573),o=n(87398),c=n(26006),u=n(68947),s=n(12050),i=n(9167);const m=function(){return l.createElement(l.Fragment,null,l.createElement(o.Z,{as:"h2"},"Controlled Components"),l.createElement(u.Z,null,"In HTML, form elements such as ",l.createElement(i.I,null,"<input>, <select>, <textarea>"),l.createElement(s.Z,null)," typically maintain their own state and update it based on user input."),l.createElement(u.Z,null,"But, in React, mutable state is typically kept in the state property of the components and updated by React. In such a case, React state is the",l.createElement(i.B,null,'"single source of truth"'),". An input form element whose value is controlled by React is called a ",l.createElement(i.B,null,'"controlled component"'),". With a controlled component, the input's value is always driven by the React state."),l.createElement(u.Z,null,l.createElement(i.IU,null,"Example:"),l.createElement(a.Z,{language:r.r.JSX},'const CustomForm = () => {\n  const [name, setName] = useState("");\n  const [experience, setHasExperience] = useState("no");\n\t\n  const handleChange = (evt) => {\n    setName(() => evt.target.value);\n  }\n\n  const handleExpChange = (evt) => {\n    setHasExperience(() => evt.target.value);\n  }\n\n  const handleSubmit = (evt) => {\n    evt.preventDefault();\n    console.log("Name: ", name);\n    console.log("React Experience: ", experience);\n  }\n\n  return <form onSubmit={handleSubmit}>\n    <label>Name: \n      <input type=”text” value={name} onChange={handleChange} />\n    <label>\n\n    <label>Have React Experience: \n      <select value={experience} onChange={handleExpChange}>\n        <option value="yes">Yes</option>\n        <option value="no">No</option>\n      </select>\n    <label>\n\n    <button type="submit">Submit</button>\n  </form>\n}\n')),l.createElement(c.Z,null,"We can pass an array into the value attribute, allowing us to select multiple options in a ","<select>"," tag.",l.createElement(a.Z,{language:r.r.JSX},'<select multiple={true} value={["a", "c"]}>\n  <option value="a">A</option>\n  <option value="b">B</option>\n  <option value="c">C</option>\n  <option value="d">D</option>\n</select>')))}},62943:(e,t,n)=>{n.r(t),n.d(t,{default:()=>d});var l=n(67294),a=n(9231),r=n(59044),o=n(87398),c=n(68947),u=n(91939),s=n(537),i=n(79745),m=n(41732);const d=function(){return(0,a.Z)("UI-Geeks: React | Forms"),l.createElement(r.Z,null,l.createElement(o.Z,null,"Forms"),l.createElement(c.Z,null,"HTML form elements work a bit differently from other DOM elements in React, because form elements naturally keep some internal state."),l.createElement(c.Z,null,l.createElement(s.default,null),l.createElement(i.default,null),l.createElement(u.default,null),l.createElement(m.default,null)))}},41732:(e,t,n)=>{n.r(t),n.d(t,{default:()=>m});var l=n(67294),a=n(81391),r=n(91573),o=n(87398),c=n(68947),u=n(12050),s=n(9167),i=[{label:l.createElement(l.Fragment,null,"React events are named using ",l.createElement(s.B,null,"camelCase"),", rather than ",l.createElement(u.Z,null),l.createElement(s.B,null,"lowercase"),".")},{label:l.createElement(l.Fragment,null,"With JSX, we pass a function as the ",l.createElement(s.B,null,"event handler"),", rather than"," ",l.createElement(s.B,null,"string"),".")}];const m=function(){return l.createElement(l.Fragment,null,l.createElement(o.Z,{as:"h2"},"Handling Events"),l.createElement(c.Z,null,"Handling events with React elements is very similar to handling events on DOM elements."),l.createElement(c.Z,null,"There are some syntax differences:",l.createElement(s.GS,{unOrdered:!0,items:i})),l.createElement(c.Z,null,l.createElement(s.B,null,"For Example, in the HTML:"),l.createElement(a.Z,{language:r.r.JSX},'<button onclick="handleClick()">Click</button>')),l.createElement(c.Z,null,l.createElement(s.B,null,"In React, same is written as:"),l.createElement(a.Z,{language:r.r.JSX},"<button onClick={handleClick}>Click</button>")),l.createElement(c.Z,null,"Another difference is that we cannot ",l.createElement(s.B,null,"return false")," to ",l.createElement(u.Z,null),l.createElement(s.I,null,"prevent default behavior")," in React. We must call ",l.createElement(u.Z,null),l.createElement(s.BI,null,"preventDefault()")," explicitly."),l.createElement(c.Z,null,l.createElement(s.B,null,"For Example, in the HTML:"),l.createElement(a.Z,{language:r.r.JSX},'<form onsubmit="return false">\n  <button type="submit">Submit</button>\n</form>\n')),l.createElement(c.Z,null,l.createElement(s.B,null,"In React, same is written as:"),l.createElement(a.Z,{language:r.r.JSX},'const Form = () => {\n  const handleSubmit = (evt) => {\n    evt.preventDefault();\n  }\n          \n  return <form onSubmit={handleSubmit}>\n    <button type="submit">Submit</button>\n  </form>\n}\n')),l.createElement(o.Z,{as:"h3"},"Synthetic Event"),l.createElement(c.Z,null,"React defines ",l.createElement(s.B,null,"synthetic events")," according to the ",l.createElement(s.BI,null,"W3C spec"),", so we don't need to worry about ",l.createElement(s.B,null,"cross-browser compatibility"),". React events do not work exactly the same as native events."))}},20651:(e,t,n)=>{n.r(t),n.d(t,{default:()=>i});var l=n(67294),a=n(81391),r=n(91573),o=n(87398),c=n(68947),u=n(12050),s=n(9167);const i=function(){return l.createElement(l.Fragment,null,l.createElement(o.Z,{as:"h2"},"Uncontrolled Components"),l.createElement(c.Z,null,"Components whose values are not controlled by React, instead are controlled by DOM itself are called ",l.createElement(s.B,null,'"uncontrolled components"'),". For example, an ",l.createElement(s.I,null,'<input type="file" />')," is always an uncontrolled component because its value can only be set by a user, and not programmatically."),l.createElement(c.Z,null,"To write an uncontrolled component, instead of writing an event handler for every state update, we can ",l.createElement(s.B,null,"use a ref")," to get form values from the DOM. ",l.createElement(s.BI,null,"Refs")," are used to access DOM nodes or React elements in uncontrolled components. React prefers to avoid using ",l.createElement(s.BI,null,"refs")," for anything that can be done declaratively."),l.createElement(c.Z,null,l.createElement(s.IU,null,"Example 1:"),l.createElement(u.Z,null)," Using ref in ",l.createElement(s.B,null,"class components.")),l.createElement(c.Z,null,"Below code focuses the ",l.createElement(s.I,null,"<input />")," element on mount."),l.createElement(c.Z,null,l.createElement(a.Z,{language:r.r.JSX},"class AutoFocusInput extends React.Component {\n  constructor(props) {\n    super(props);\n    this.textInput = React.createRef();\n  }\n\t\n  componentDidMount() {\n    this.textInput.current.focusTextInput();\n  }\n\n  render() {\n    return <input type=”text” ref={this.textInput} />\n  }\n}")),l.createElement(c.Z,null,l.createElement(s.IU,null,"Example 2:"),l.createElement(u.Z,null)," Using ref in ",l.createElement(s.B,null,"function components.")),l.createElement(c.Z,null,l.createElement(a.Z,{language:r.r.JSX},"const AutoFocusInput = () => {\n  const textInput = useRef();\n  useEffect(() =>  {\n    textInput.current.focusTextInput();\n  },[ ]);\n  return <input type=”text” ref={this.textInput} />\n}\n")),l.createElement(c.Z,null,"React will assign the ",l.createElement(s.BI,null,'"current"')," property with the DOM element when the component ",l.createElement(s.I,null,"mounts"),", and assign it back to ",l.createElement(s.BI,null,"null"),l.createElement(u.Z,null)," when it ",l.createElement(s.I,null,"unmounts"),". For ",l.createElement(s.I,null,"class components"),",",l.createElement(u.Z,null)," ",l.createElement(s.BI,null,"ref")," updates happen before ",l.createElement(u.Z,null),l.createElement(s.BI,null,"componentDidMount()")," or ",l.createElement(s.BI,null,"componentDidUpdate()")," lifecycle methods."))}},79745:(e,t,n)=>{n.r(t),n.d(t,{default:()=>o});var l=n(67294),a=n(20651),r=n(56636);const o=function(){return l.createElement(l.Fragment,null,l.createElement(a.default,null),l.createElement(r.default,null))}},56636:(e,t,n)=>{n.r(t),n.d(t,{default:()=>u});var l=n(67294),a=n(87398),r=n(68947),o=n(9167),c=[{label:"Managing focus, text selection, or media playback."},{label:"Integrating with third-party DOM libraries."}];const u=function(){return l.createElement(l.Fragment,null,l.createElement(a.Z,{as:"h3"},"When to use Uncontrolled Components"),l.createElement(r.Z,null,"Since an uncontrolled component keeps the source of truth in the DOM, it is sometimes easier to integrate React and non-React code when using uncontrolled components. It can be slightly less code if we want to be quick and dirty. Otherwise, we should use controlled components."),l.createElement(o.GS,{unOrdered:!0,items:c}))}},59044:(e,t,n)=>{n.d(t,{Z:()=>I});var l=n(4942),a=n(94184),r=n.n(a),o=n(67294),c=n(83819),u=n(93379),s=n.n(u),i=n(7795),m=n.n(i),d=n(90569),p=n.n(d),E=n(3565),h=n.n(E),f=n(19216),v=n.n(f),b=n(44589),g=n.n(b),Z=n(94364),y={};y.styleTagTransform=g(),y.setAttributes=h(),y.insert=p().bind(null,"head"),y.domAPI=m(),y.insertStyleElement=v(),s()(Z.Z,y),Z.Z&&Z.Z.locals&&Z.Z.locals;var x=function(e){var t=e.children,n=r()((0,l.Z)({},"".concat(c.HL,"-container"),!0));return o.createElement("div",{className:n},t)};const I=(0,o.memo)(x)},26006:(e,t,n)=>{n.d(t,{Z:()=>U});var l=n(4942),a=n(94184),r=n.n(a),o=n(67294),c=n(14289),u=n(78146),s=n(67115),i=n(76792),m=n(32209),d=n(41485),p=n(39602),E=n(44680),h=n(85893);const f=(0,p.Z)("h4");f.displayName="DivStyledAsH4";const v=(0,E.Z)("alert-heading",{Component:f}),b=(0,E.Z)("alert-link",{Component:s.Z}),g={variant:"primary",show:!0,transition:m.Z,closeLabel:"Close alert"},Z=o.forwardRef(((e,t)=>{const{bsPrefix:n,show:l,closeLabel:a,closeVariant:o,className:s,children:p,variant:E,onClose:f,dismissible:v,transition:b,...g}=(0,c.Ch)(e,{show:"onClose"}),Z=(0,i.vE)(n,"alert"),y=(0,u.Z)((e=>{f&&f(!1,e)})),x=!0===b?m.Z:b,I=(0,h.jsxs)("div",{role:"alert",...x?void 0:g,ref:t,className:r()(s,Z,E&&`${Z}-${E}`,v&&`${Z}-dismissible`),children:[v&&(0,h.jsx)(d.Z,{onClick:y,"aria-label":a,variant:o}),p]});return x?(0,h.jsx)(x,{unmountOnExit:!0,...g,ref:void 0,in:l,children:I}):l?I:null}));Z.displayName="Alert",Z.defaultProps=g;const y=Object.assign(Z,{Link:b,Heading:v});var x=n(83819),I=n(93379),w=n.n(I),B=n(7795),k=n.n(B),C=n(90569),R=n.n(C),S=n(3565),D=n.n(S),F=n(19216),M=n.n(F),O=n(44589),H=n.n(O),T=n(11137),N={};N.styleTagTransform=H(),N.setAttributes=D(),N.insert=R().bind(null,"head"),N.domAPI=k(),N.insertStyleElement=M(),w()(T.Z,N),T.Z&&T.Z.locals&&T.Z.locals;var A=function(e){var t=e.children,n=e.noteText,a=void 0===n?"Note":n,c=e.variant,u=void 0===c?"primary":c,s=r()((0,l.Z)({},"".concat(x.HL,"-note"),!0));return o.createElement("div",{className:s},o.createElement("div",{className:"note-text"},a),o.createElement(y,{key:u,variant:u},t))};const U=(0,o.memo)(A)},9231:(e,t,n)=>{n.d(t,{Z:()=>a});var l=n(67294);const a=function(e){(0,l.useEffect)((function(){return document.title=e,function(){document.title="UI Geeks | UI Learning Platform"}}),[])}},94364:(e,t,n)=>{n.d(t,{Z:()=>c});var l=n(8081),a=n.n(l),r=n(23645),o=n.n(r)()(a());o.push([e.id,".ui-geeks-container{padding:1rem}\n",""]);const c=o},11137:(e,t,n)=>{n.d(t,{Z:()=>c});var l=n(8081),a=n.n(l),r=n(23645),o=n.n(r)()(a());o.push([e.id,".ui-geeks-note{margin-top:1.2rem;margin-bottom:3rem;font-style:italic}.ui-geeks-note .note-text{font-style:italic;position:relative;font-weight:bold;top:13px;z-index:9;margin-left:15px;background-color:#aba8f1;width:fit-content;padding:2px 10px 2px 10px;border-radius:4px}\n",""]);const c=o}}]);