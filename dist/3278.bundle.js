"use strict";(self.webpackChunkui_geeks_in=self.webpackChunkui_geeks_in||[]).push([[3278,1827,1497,2159,7220,4788,2049,5811],{71827:(e,t,n)=>{n.r(t),n.d(t,{default:()=>m});var l=n(67294),a=n(81391),r=n(91573),o=n(87398),c=n(68947),u=n(12050),s=n(9167);const m=function(){return l.createElement(l.Fragment,null,l.createElement(o.Z,{as:"h3"},"Class.contextType"),l.createElement(c.Z,null,"The ",l.createElement(s.BI,null,"contextType")," property can be used to assign a",l.createElement(u.Z,null)," ",l.createElement(s.B,null,"Context object")," created by ",l.createElement(s.I,null,"React.createContext()"),". Using this property lets us consume the nearest ",l.createElement(s.I,null,"current value"),l.createElement(u.Z,null)," using ",l.createElement(s.BI,null,'"this.context"'),"."),l.createElement(c.Z,null,l.createElement(s.IU,null,"Syntax:"),l.createElement(a.Z,{language:r.r.JSX},"MyComponent.contextType = ContextObject;")),l.createElement(c.Z,null,l.createElement(s.IU,null,"Example:"),l.createElement(a.Z,{language:r.r.JSX},'const user = { name : "Default User" };\nconst UserContext = React.createContext(user);\n\nclass MyComponent extends React.Component {\n  render() {\n    const value = this.context;\n    return <div>{value.name}</div>\n  }\n}\n\nMyComponent.contextType = UserContext;')))}},21894:(e,t,n)=>{n.r(t),n.d(t,{default:()=>i});var l=n(67294),a=n(87398),r=n(71827),o=n(51497),c=n(32159),u=n(47220),s=n(90112),m=n(4788);const i=function(){return l.createElement(l.Fragment,null,l.createElement(a.Z,{as:"h2"},"Context API"),l.createElement(s.default,null),l.createElement(u.default,null),l.createElement(r.default,null),l.createElement(o.default,null),l.createElement(c.default,null),l.createElement(m.default,null))}},51497:(e,t,n)=>{n.r(t),n.d(t,{default:()=>m});var l=n(67294),a=n(81391),r=n(91573),o=n(87398),c=n(68947),u=n(12050),s=n(9167);const m=function(){return l.createElement(l.Fragment,null,l.createElement(o.Z,{as:"h3"},"Context.Consumer"),l.createElement(c.Z,null,"It is a ",l.createElement(s.B,null,"React component")," that ",l.createElement(s.BI,null,"subscribes")," to ",l.createElement(u.Z,null),l.createElement(s.I,null,"context changes"),". This component lets us subscribe to a context within a ",l.createElement(s.B,null,"function component"),"."),l.createElement(c.Z,null,l.createElement(s.IU,null,"Syntax:"),l.createElement(a.Z,{language:r.r.JSX},"<ReactContext.Consumer>\n  { value => { /* Render elements based on context value */ }\n</ReactContext.Consumer>\n")),l.createElement(c.Z,null,"This component requires a ",l.createElement(s.B,null,"function as a child"),". The function receives the current context value and returns a React node. The",l.createElement(u.Z,null)," ",l.createElement(s.BI,null,"value")," argument will be equal to the ",l.createElement(u.Z,null),l.createElement(s.BI,null,"value prop")," of the closest ",l.createElement(s.BI,null,"Provider")," for this context in the tree."))}},32159:(e,t,n)=>{n.r(t),n.d(t,{default:()=>s});var l=n(67294),a=n(81391),r=n(91573),o=n(87398),c=n(68947),u=n(9167);const s=function(){return l.createElement(l.Fragment,null,l.createElement(o.Z,{as:"h3"},"Context.displayName"),l.createElement(c.Z,null,"Context object accepts a ",l.createElement(u.I,null,"displayName")," string property. React DevTools uses this name to determine what to display for the context. This is used in ",l.createElement(u.I,null,"rare-cases"),"."),l.createElement(c.Z,null,l.createElement(u.IU,null,"Example:"),l.createElement(a.Z,{language:r.r.JSX},'const user = { name : "Default User" };\nconst UserContext = React.createContext(user);\nUserContext.displayName = "UserContextAliasName";\n\n<UserContext.Provider>\n// "UserContextAliasName.Provider" in DevTools\n\n<UserContext.Consumer>\n// "UserContextAliasName.Consumer" in DevTools\n')))}},47220:(e,t,n)=>{n.r(t),n.d(t,{default:()=>m});var l=n(67294),a=n(81391),r=n(91573),o=n(87398),c=n(68947),u=n(12050),s=n(9167);const m=function(){return l.createElement(l.Fragment,null,l.createElement(o.Z,{as:"h3"},"Context.Provider"),l.createElement(c.Z,null,"Every Context object comes with a ",l.createElement(s.B,null,"Provider React Component")," that allows consuming components to subscribe to context changes."),l.createElement(c.Z,null,l.createElement(s.IU,null,"Syntax:"),l.createElement(a.Z,{language:r.r.JSX},"<ReactContext.Provider value={/* some value */} >")),l.createElement(c.Z,null,"The ",l.createElement(s.BI,null,"Provider")," component accepts a ",l.createElement(s.BI,null,"value")," ",l.createElement(s.I,null,"prop")," to be passed to consuming components that are descendants of this Provider. One Provider can be connected to many consumers. Providers can be nested to override values deeper within the tree."),l.createElement(c.Z,null,"All consumers that are descendants of a Provider will re-render whenever Provider's ",l.createElement(s.BI,null,"value")," ",l.createElement(s.I,null,"prop")," changes. The propagation from Provider to consumer is not subject to the ",l.createElement(u.Z,null),l.createElement(s.I,null,"shouldComponentUpdate()")," method, so the consumer is updated even when an ancestor component skips an update."))}},90112:(e,t,n)=>{n.r(t),n.d(t,{default:()=>i});var l=n(67294),a=n(81391),r=n(91573),o=n(87398),c=n(26006),u=n(68947),s=n(12050),m=n(9167);const i=function(){return l.createElement(l.Fragment,null,l.createElement(o.Z,{as:"h3"},"React.createContext"),l.createElement(u.Z,null,"This method creates a ",l.createElement(m.BI,null,"Context")," object. When React renders a component that ",l.createElement(m.I,null,"subscribes")," to this ",l.createElement(m.BI,null,"Context")," object it will read the ",l.createElement(m.I,null,"current context value")," form the closest matching",l.createElement(s.Z,null)," ",l.createElement(m.B,null,"Provider")," above it in the tree."),l.createElement(u.Z,null,l.createElement(m.IU,null,"Syntax:"),l.createElement(a.Z,{language:r.r.JSX},"const ReactContext = React.createContext(defaultValue)")),l.createElement(u.Z,null,l.createElement(m.B,null,"defaultValue"),": The ",l.createElement(m.I,null,"defaultValue")," argument is only used when a component does not have a matching Provider above it in the tree."),l.createElement(c.Z,null,"Passing ",l.createElement(m.B,null,"undefined")," as a ",l.createElement(m.B,null,"Provider value")," does not cause components to use ",l.createElement(m.B,null,"defaultValue"),"."))}},4788:(e,t,n)=>{n.r(t),n.d(t,{default:()=>u});var l=n(67294),a=n(87398),r=n(68947),o=n(9167),c=[{label:l.createElement(l.Fragment,null,"When ",l.createElement(o.B,null,"Provider value prop")," changes, it will ",l.createElement(o.B,null,"re-render")," all the child components below the current component, irrespective of the implementation of ",l.createElement(o.I,null,"shouldComponentUpdate()")," lifecycle method. This may cause performance issues.")},{label:l.createElement(l.Fragment,null,l.createElement(o.B,null,"Provider value prop")," update has to be made with caution, because it will only ",l.createElement(o.B,null,"re-render")," the child components ",l.createElement(o.B,null,"below")," the current component and not the components ",l.createElement(o.B,null,"above")," the current component in the component tree.")}];const u=function(){return l.createElement(l.Fragment,null,l.createElement(a.Z,{as:"h2"},"Issues using Context"),l.createElement(r.Z,null,"Although Context is a good fit for sharing data between parent and child components in a deeply nested component tree. Still, there are a couple of issues with the re-rendering mechanism of Context."),l.createElement(r.Z,null,"Let's learn few of the issues:"),l.createElement(o.GS,{unOrdered:!0,expanded:!0,items:c}))}},42049:(e,t,n)=>{n.r(t),n.d(t,{default:()=>s});var l=n(67294),a=n(81391),r=n(91573),o=n(68947),c=n(12050),u=n(9167);const s=function(){return l.createElement(l.Fragment,null,l.createElement(o.Z,null,"Context provides a way to pass data through the ",l.createElement(u.I,null,"component tree"),l.createElement(c.Z,null)," without having to pass ",l.createElement(u.I,null,"props")," down manually at every level."),l.createElement(o.Z,null,"In React application, data is passed ",l.createElement(u.B,null,"top-down")," (parent to child component) via props, but this approach can lead to a concept called",l.createElement(u.B,null,'"prop drilling"'),", where we have to add ",l.createElement(u.I,null,"prop")," to every child component in the tree, whether or not that child component needs that",l.createElement(c.Z,null)," ",l.createElement(u.I,null,"prop"),". This continuous drilling is required to send the props to the desired component in the tree."),l.createElement(o.Z,null,l.createElement(u.IU,null,"Example:"),l.createElement(a.Z,{language:r.r.JSX},'const PropDrill = () => {\n  const userName = "John";\n  return <FirstComponent name = {userName} />\n}\n\nconst FirstComponent = (props) => {\n  const { name } = props;\n  // This do not use "name", but still we have to pass\n  // in order to pass the value to next child in tree\n  return <SecondComponent name = {name} />\n}\n\nconst SecondComponent = (props) => {\n  // This component needs "name" prop to display\n  const { name } = props;\n  return <div>Username is: {name}</div>\n}')))}},75811:(e,t,n)=>{n.r(t),n.d(t,{default:()=>m});var l=n(67294),a=n(81391),r=n(91573),o=n(87398),c=n(68947),u=n(12050),s=n(9167);const m=function(){return l.createElement(l.Fragment,null,l.createElement(o.Z,{as:"h2"},"When to use Context"),l.createElement(c.Z,null,"Context is designed to share data that can be considered ",l.createElement(s.B,null,'"global"'),l.createElement(u.Z,null)," for a tree of React components, such as the ",l.createElement(u.Z,null),l.createElement(s.I,null,"current user"),", ",l.createElement(s.I,null,"theme"),", or ",l.createElement(s.I,null,"preferred language"),". By using context, we can avoid passing props to intermediate elements of the child tree."),l.createElement(c.Z,null,l.createElement(s.IU,null,"Example:"),l.createElement(a.Z,{language:r.r.JSX},'const user = { name : "Default User", authenticated: false };\nconst UserContext = React.createContext(user);'),l.createElement(a.Z,{language:r.r.JSX},'const LoginButton = () => { \n  const userInfo = useContext(UserContext);\n  return <div>\n    <span>Username: {userInfo.name}</span>\n    <button>{userInfo.authenticated  ? "Logout" : "Login"}</button>\n  </div>\n}'),l.createElement(a.Z,{language:r.r.JSX},'const Home = () => { \n  const [userInfo, setUserInfo]  = useState(null) ;\t\n  const toggleLogin = () => { \n    setUserInfo(()=> {\n      return { name : "Home User", authenticated: true } \n    });\n  }\n\n  return <UserContext.Provider value={userInfo }>\n    <LoginButton />\n    <button onClick={toggleLogin}>Toggle Login</button>\n  </UserContext.Provider>\n}')),l.createElement(c.Z,null,"In the above code, ",l.createElement(s.B,null,"LoginButton")," component will render below elements on the ",l.createElement(s.B,null,"mount")," of the component.",l.createElement(a.Z,{language:r.r.HTML},"<span>Username: Default User</span>\n<button>Login</button>\n")),l.createElement(c.Z,null,"But once a user clicks on ",l.createElement(s.BI,null,"toggleButton")," in the ",l.createElement(s.B,null,"Home"),l.createElement(u.Z,null)," component, the ",l.createElement(s.B,null,"Home")," component will be ",l.createElement(u.Z,null),l.createElement(s.I,null,"re-rendered"),", because the value of the context will change. Now the ",l.createElement(s.B,null,"LoginButton")," component will render the below elements.",l.createElement(a.Z,{language:r.r.HTML},"<span>Username: Home User</span>\n<button>Logout</button>")))}},51451:(e,t,n)=>{n.r(t),n.d(t,{default:()=>m});var l=n(67294),a=n(9231),r=n(59044),o=n(87398),c=n(21894),u=n(42049),s=n(75811);const m=function(){return(0,a.Z)("UI-Geeks: React | Context"),l.createElement(r.Z,null,l.createElement(o.Z,null,"Context"),l.createElement(u.default,null),l.createElement(s.default,null),l.createElement(c.default,null))}}}]);