"use strict";(self.webpackChunkui_geeks_in=self.webpackChunkui_geeks_in||[]).push([[1796,1602,1480,2835,2585,2993,8615],{51796:(e,t,n)=>{n.r(t),n.d(t,{default:()=>d});var l=n(67294),a=n(87398),r=n(68947),u=n(1602),c=n(11480),o=n(32835),s=n(72585),i=n(22993),m=n(8615);const d=function(){return l.createElement(l.Fragment,null,l.createElement(a.Z,{as:"h2"},"Additional Hooks"),l.createElement(r.Z,null,"The following Hooks are either variants of the basic ones or only needed for specific edge cases."),l.createElement(i.default,null),l.createElement(u.default,null),l.createElement(s.default,null),l.createElement(m.default,null),l.createElement(c.default,null),l.createElement(o.default,null))}},1602:(e,t,n)=>{n.r(t),n.d(t,{default:()=>i});var l=n(67294),a=n(81391),r=n(91573),u=n(87398),c=n(68947),o=n(12050),s=n(9167);const i=function(){return l.createElement(l.Fragment,null,l.createElement(u.Z,{as:"h3"},"useCallback()"),l.createElement(c.Z,null,"This Hook is used to create a ",l.createElement(s.I,null,"memoized callback"),", which will execute only on the change of the given dependencies."),l.createElement(c.Z,null,l.createElement(s.IU,null,"Syntax:"),l.createElement(a.Z,{language:r.r.JSX},"const memoizedCallback = useCallback(() => {\n  // expensive expressions\n}, [/* dependency list */])")),l.createElement(c.Z,null,"The ",l.createElement(s.BI,null,"useCallback")," will return a memoized version of the",l.createElement(o.Z,null)," ",l.createElement(s.B,null,"callback")," that only changes if one of the dependencies has changed."),l.createElement(c.Z,null,"The ",l.createElement(s.BI,null,"useCallback(fn, deps)")," is equivalent to",l.createElement(o.Z,null)," ",l.createElement(s.BI,null,"useMemo(() => fn, deps)"),"."),l.createElement(c.Z,null,l.createElement(s.IU,null,"Example:"),l.createElement(a.Z,{language:r.r.JSX},"const memoizedCallback = useCallback(() => {\n  doSomeExpensive(a, b);\n}, [a, b]);\n")),l.createElement(c.Z,null,"In the above code, ",l.createElement(s.B,null,'"doSomeExpensive"')," method will be called on change on the given dependencies ",l.createElement(s.B,null,'"a"')," and ",l.createElement(s.B,null,'"b"'),"."))}},11480:(e,t,n)=>{n.r(t),n.d(t,{default:()=>s});var l=n(67294),a=n(81391),r=n(91573),u=n(87398),c=n(68947),o=n(9167);const s=function(){return l.createElement(l.Fragment,null,l.createElement(u.Z,{as:"h3"},"useImperativeHandle()"),l.createElement(c.Z,null,"This Hook customizes the instance value that is exposed to parent components when using ref. The useImperativeHandle should be used with forwardRef."),l.createElement(c.Z,null,l.createElement(o.IU,null,"Syntax:"),l.createElement(a.Z,{language:r.r.JSX},"useImperativeHandle(ref, createHandle, [deps])")),l.createElement(c.Z,null,l.createElement(o.IU,null,"Example:"),l.createElement(a.Z,{language:r.r.JSX},"const CustomInput = (props, ref) => {\n  const inputRef = useRef();\n  useImperativeHandle(ref, () => ({\n    focus: () => { inputRef.current.focus(); }\n  }));\n\n  return <input ref={inputRef} />;\n}\n\nCustomInput = forwardRef(CustomInput);\n")),l.createElement(c.Z,null,"In above code, a parent component that renders",l.createElement(o.BI,null,"<CustomInput ref={inputRef} />")," would be able to call",l.createElement(o.BI,null,"inputRef.current.focus()"),"."))}},32835:(e,t,n)=>{n.r(t),n.d(t,{default:()=>o});var l=n(67294),a=n(87398),r=n(68947),u=n(12050),c=n(9167);const o=function(){return l.createElement(l.Fragment,null,l.createElement(a.Z,{as:"h3"},"useLayoutEffect()"),l.createElement(r.Z,null,"This Hook is identical to ",l.createElement(c.BI,null,"useEffect"),", but it fires",l.createElement(u.Z,null)," ",l.createElement(c.B,null,"synchronously")," after all DOM mutations. Use this Hook to read layout from the DOM and synchronously re-render. Updates scheduled inside ",l.createElement(c.I,null,"useLayoutEffect")," will be flushed synchronously, before the browser has a chance to paint."),l.createElement(r.Z,null,"Prefer the standard ",l.createElement(c.I,null,"useEffect")," when possible to avoid blocking visual updates."))}},72585:(e,t,n)=>{n.r(t),n.d(t,{default:()=>s});var l=n(67294),a=n(81391),r=n(91573),u=n(87398),c=n(68947),o=n(9167);const s=function(){return l.createElement(l.Fragment,null,l.createElement(u.Z,{as:"h3"},"useMemo()"),l.createElement(c.Z,null,"The ",l.createElement(o.B,null,"useMemo")," will only recompute the ",l.createElement(o.B,null,"memoized value")," when one of the dependencies has changed. This optimization helps to avoid expensive calculations on every render. If no dependency array is provided, a new value will be computed on every render."),l.createElement(c.Z,null,l.createElement(o.IU,null,"Syntax:"),l.createElement(a.Z,{language:r.r.JSX},"const memoizedValue = useMemo(() => expensiveFunction, [/* dependencies */]);")),l.createElement(c.Z,null,l.createElement(o.IU,null,"Example:"),l.createElement(a.Z,{language:r.r.JSX},"const memoizedValue = useMemo(() => \n  computeExpensiveValue(a, b),\n[a, b]);")))}},22993:(e,t,n)=>{n.r(t),n.d(t,{default:()=>i});var l=n(67294),a=n(81391),r=n(91573),u=n(87398),c=n(68947),o=n(12050),s=n(9167);const i=function(){return l.createElement(l.Fragment,null,l.createElement(u.Z,{as:"h3"},"useReducer()"),l.createElement(c.Z,null,"This Hooks is an alternative to ",l.createElement(s.I,null,"useState")," Hook. It is usually preferable over ",l.createElement(s.I,null,"useState")," when we have complex state logic that involves multiple sub-values or when the next state depends on the previous one. useReducer also optimizes the performance of the component."),l.createElement(c.Z,null,l.createElement(s.IU,null,"Syntax:"),l.createElement(a.Z,{language:r.r.JSX},"const [state, dispatch] = useReducer(reducer, intialArg, init);")),l.createElement(c.Z,null,l.createElement(s.B,null,"state"),": This variable holds the current value of the state."),l.createElement(c.Z,null,l.createElement(s.B,null,"dispatch"),": This method is used to trigger a change to the state value."),l.createElement(c.Z,null,l.createElement(s.B,null,"reducer"),": This is a method of type ",l.createElement(o.Z,null),l.createElement(s.BI,null,"(state, action) => newState"),". It accepts ",l.createElement(s.B,null,'"action"'),l.createElement(o.Z,null)," from ",l.createElement(s.B,null,"dispatch"),", uses the ",l.createElement(s.BI,null,"current state")," to compute ",l.createElement(s.BI,null,"newState")," and returns the newState."),l.createElement(c.Z,null,l.createElement(s.B,null,"intialArg"),": It is the initial value of the state."),l.createElement(c.Z,null,l.createElement(s.B,null,"init"),": This is an ",l.createElement(s.I,null,"optional function"),", used for ",l.createElement(o.Z,null),l.createElement(s.I,null,"lazy initialization")," of the ",l.createElement(s.I,null,"state"),". If provided, the initial state will be set to ",l.createElement(s.BI,null,"init(initialArg)"),". It lets us extract the logic for calculating the initial state outside the reducer."),l.createElement(c.Z,null,l.createElement(s.IU,null,"Example:"),l.createElement(a.Z,{language:r.r.JSX},"const init = (initialCount) => {\n  return { count: initialCount };\n}"),l.createElement(a.Z,{language:r.r.JSX},'const reducer(state, action) {\n  switch(action.type) {\n    case "increment": return { count : state.count + 1 };\n    case "decrement": return { count : state.count - 1 };\n    case "reset": return init(action.payload);\n    default: throw new Error();\n  }\n}')),l.createElement(a.Z,{language:r.r.JSX},'const Counter = (props) => {\n  const { initialCount } = props;\n  const [state, dispatch] = useReducer(reducer, initialCount, init);\n\n  const handleReset = () => {\n    dispatch({ type: "reset", payload: initialCount });\n  }\n  const handleIncrement = () => { dispatch({ type: "increment" }); \t}\n  const handleDecrement = () => { dispatch({ type: "decrement" }); }\n\n  return <>\n    Count: {state.count}\n    <button onClick={handleReset}>Reset</button>\n    <button onClick={handleIncrement}>Increment</button>\n    <button onClick={handleDecrement}>Decrement</button>\n  </>\n}'))}},8615:(e,t,n)=>{n.r(t),n.d(t,{default:()=>i});var l=n(67294),a=n(81391),r=n(91573),u=n(87398),c=n(68947),o=n(12050),s=n(9167);const i=function(){return l.createElement(l.Fragment,null,l.createElement(u.Z,{as:"h3"},"useRef()"),l.createElement(c.Z,null,"The ",l.createElement(s.B,null,"useRef")," returns a mutable ",l.createElement(s.I,null,"ref")," object whose",l.createElement(o.Z,null)," ",l.createElement(s.BI,null,'".current"')," property is initialized to the passed argument ",l.createElement(s.I,null,"(initialValue)"),". The returned object will persist for the full lifetime of the component. This hook is used with ",l.createElement(o.Z,null),l.createElement(s.B,null,"uncontrolled components"),"."),l.createElement(c.Z,null,l.createElement(s.IU,null,"Example:"),l.createElement(a.Z,{language:r.r.JSX},'const AutoFocusInput = () => {\n  const textInput = useRef();\n  useEffect(() =>  {\n    textInput.current.focusTextInput();\n  },[ ]);\n  return <input type="text" ref={this.textInput} />\n}\n')),l.createElement(c.Z,null,"React will assign the ",l.createElement(s.BI,null,'"current"')," property with the DOM element when the component ",l.createElement(s.I,null,"mounts"),", and assign it back to ",l.createElement(s.BI,null,"null"),l.createElement(o.Z,null)," when it ",l.createElement(s.I,null,"unmounts"),". For ",l.createElement(s.I,null,"class components"),",",l.createElement(o.Z,null)," ",l.createElement(s.BI,null,"ref")," updates happen before ",l.createElement(o.Z,null),l.createElement(s.BI,null,"componentDidMount()")," or ",l.createElement(s.BI,null,"componentDidUpdate()")," lifecycle methods."))}}}]);